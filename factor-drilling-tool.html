<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asian Handicap Factor Drilling Tool</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', monospace, sans-serif; background: #1a1a1a; color: #e0e0e0; font-size: 11px; }
        
        .container { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        .top-bar { background: #2d2d2d; padding: 8px 12px; border-bottom: 1px solid #404040; flex-shrink: 0; }
        .app-title { color: #00ff88; font-weight: bold; font-size: 14px; margin-bottom: 4px; }
        .status-line { color: #888; font-size: 10px; }
        
        .selected-panel { background: #252525; padding: 8px 12px; border-bottom: 1px solid #404040; min-height: 60px; max-height: 100px; flex-shrink: 0; overflow-y: auto; }
        .selected-title { color: #00bfff; font-size: 10px; font-weight: bold; margin-bottom: 4px; text-transform: uppercase; }
        .selected-factors-list { display: flex; flex-wrap: wrap; gap: 4px; }
        .selected-tag { background: #1565c0; color: white; padding: 2px 6px; border-radius: 2px; font-size: 9px; display: flex; align-items: center; gap: 4px; }
        .selected-tag.mandatory { background: #d32f2f; }
        .remove-x { cursor: pointer; font-weight: bold; }
        .remove-x:hover { color: #ff6b6b; }
        
        .main-content { display: flex; flex: 1; min-height: 0; }
        .sidebar { width: 280px; background: #1e1e1e; border-right: 1px solid #404040; overflow-y: auto; flex-shrink: 0; }
        .results-panel { flex: 1; background: #1a1a1a; overflow-y: auto; min-width: 0; }
        
        .mandatory-section { background: #2d1b1b; border-bottom: 1px solid #404040; padding: 8px; }
        .mandatory-title { color: #ff6b6b; font-size: 9px; font-weight: bold; text-transform: uppercase; margin-bottom: 4px; }
        .mandatory-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        .mandatory-item { background: #3d2d2d; padding: 4px 6px; border-radius: 2px; cursor: pointer; border: 1px solid transparent; }
        .mandatory-item:hover { border-color: #ff6b6b; }
        .mandatory-item.selected { background: #d32f2f; color: white; }
        .mandatory-item-name { font-weight: bold; font-size: 9px; }
        .mandatory-item-desc { font-size: 8px; color: #aaa; margin-top: 1px; }
        
        .factor-section { padding: 6px; border-bottom: 1px solid #333; }
        .factor-title { color: #00bfff; font-size: 9px; font-weight: bold; text-transform: uppercase; margin-bottom: 4px; padding: 2px 4px; background: #1a1a1a; }
        .factor-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2px; }
        .factor-item { background: #2a2a2a; padding: 3px 5px; border-radius: 2px; cursor: pointer; border: 1px solid transparent; }
        .factor-item:hover { border-color: #00bfff; background: #333; }
        .factor-item.selected { background: #1565c0; color: white; }
        .factor-item.negative-roi { opacity: 0.7; }
        
        .mandatory-item.negative-roi { opacity: 0.7; }
        .factor-name { font-weight: bold; font-size: 9px; }
        .factor-desc { font-size: 8px; color: #888; margin-top: 1px; line-height: 1.2; }
        .factor-roi { font-size: 8px; font-weight: bold; margin-top: 1px; }
        .roi-positive { color: #00ff88; }
        .roi-negative { color: #ff6b6b; opacity: 0.7; }
        .roi-neutral { color: #888; opacity: 0.7; }
        
        .results-content { padding: 12px; height: 100%; overflow-y: auto; box-sizing: border-box; }
        .summary { background: #252525; border: 1px solid #404040; padding: 10px; margin-bottom: 12px; flex-shrink: 0; }
        .summary-header { color: #00ff88; font-size: 10px; font-weight: bold; margin-bottom: 6px; text-transform: uppercase; }
        .summary-stats { font-size: 9px; color: #aaa; margin-bottom: 8px; line-height: 1.3; }
        .summary-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
        .summary-metric { text-align: center; }
        .summary-value { font-size: 12px; font-weight: bold; margin-bottom: 2px; }
        .summary-label { font-size: 8px; color: #888; text-transform: uppercase; }
        
        .profit-positive { color: #00ff88; }
        .profit-negative { color: #ff6b6b; }
        .profit-neutral { color: #888; }
        
        .records-section { flex-shrink: 0; }
        .records-header { color: #00bfff; font-size: 10px; font-weight: bold; margin-bottom: 6px; text-transform: uppercase; }
        .records-table { width: 100%; border-collapse: collapse; font-size: 9px; table-layout: fixed; }
        .records-table th { background: #2d2d2d; color: #00bfff; padding: 4px 6px; text-align: left; font-weight: bold; font-size: 8px; text-transform: uppercase; border: 1px solid #404040; position: sticky; top: 0; z-index: 10; }
        .records-table td { padding: 3px 6px; border: 1px solid #333; background: #1e1e1e; word-wrap: break-word; }
        .records-table tr:nth-child(even) td { background: #252525; }
        .records-table tr:hover td { background: #2a2a2a; }
        
        .loading { text-align: center; padding: 40px; color: #888; font-size: 10px; }
        .error { color: #ff6b6b; background: #2d1b1b; padding: 8px; border: 1px solid #ff6b6b; margin: 8px 0; font-size: 10px; }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #404040; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="app-title">Asian Handicap Factor Analysis</div>
            <div class="status-line" id="status-line">Initializing...</div>
        </div>
        
        <!-- Selected Factors Panel -->
        <div class="selected-panel">
            <div class="selected-title">Active Strategy Factors</div>
            <div class="selected-factors-list" id="selected-factors-list">
                <div style="color: #666; font-size: 9px;">Select betting side and stake method to begin</div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Mandatory Factors -->
                <div class="mandatory-section">
                    <div class="mandatory-title">Required Parameters</div>
                    <div id="mandatory-factors"></div>
                </div>
                
                <!-- Available Factors -->
                <div id="available-factors"></div>
            </div>
            
            <!-- Results Panel -->
            <div class="results-panel">
                <div class="results-content">
                    <div id="results">
                        <div class="loading">Loading strategy engine...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let allMatches = [];
        let selectedSide = null;
        let selectedSize = null;
        let selectedFactors = [];
        let currentResults = null;
        
        // Factor definitions (loaded dynamically from factor_definitions.js)
        let factorDefinitions = {};
        
        // PERFORMANCE OPTIMIZATION: Caching system
        const performanceCache = {
            // Cache for factor expression evaluations: "matchKey|expression" -> boolean
            factorEvaluations: new Map(),
            
            // Cache for Asian Handicap calculations: "homeScore|awayScore|handicap|betSide|odds|stake" -> result
            asianHandicapResults: new Map(),
            
            // Cache for filtered match lists: "factorCombinationHash" -> matchArray
            filteredMatches: new Map(),
            
            // Cache for complete betting results: "matchListHash|sideKey|sizeKey" -> results
            bettingResults: new Map(),
            
            // Performance stats
            stats: {
                factorEvalHits: 0,
                factorEvalMisses: 0,
                ahCalcHits: 0,
                ahCalcMisses: 0,
                matchFilterHits: 0,
                matchFilterMisses: 0,
                bettingResultHits: 0,
                bettingResultMisses: 0
            },
            
            // Clear all caches
            clearAll() {
                this.factorEvaluations.clear();
                this.asianHandicapResults.clear();
                this.filteredMatches.clear();
                this.bettingResults.clear();
                console.log('🧹 Performance cache cleared');
            },
            
            // Get cache hit rates
            getHitRates() {
                const factorRate = this.stats.factorEvalHits / (this.stats.factorEvalHits + this.stats.factorEvalMisses) * 100;
                const ahRate = this.stats.ahCalcHits / (this.stats.ahCalcHits + this.stats.ahCalcMisses) * 100;
                const filterRate = this.stats.matchFilterHits / (this.stats.matchFilterHits + this.stats.matchFilterMisses) * 100;
                const resultRate = this.stats.bettingResultHits / (this.stats.bettingResultHits + this.stats.bettingResultMisses) * 100;
                
                return {
                    factorEvaluation: isNaN(factorRate) ? 0 : factorRate.toFixed(1),
                    asianHandicap: isNaN(ahRate) ? 0 : ahRate.toFixed(1),
                    matchFilter: isNaN(filterRate) ? 0 : filterRate.toFixed(1),
                    bettingResult: isNaN(resultRate) ? 0 : resultRate.toFixed(1)
                };
            }
        };
        
        // Asian Handicap Calculator (browser version with caching)
        class AsianHandicapCalculator {
            static calculate(homeScore, awayScore, handicap, betSide, odds, stake) {
                // Create cache key for this calculation
                const cacheKey = `${homeScore}|${awayScore}|${handicap}|${betSide}|${odds}|${stake}`;
                
                // Check cache first
                if (performanceCache.asianHandicapResults.has(cacheKey)) {
                    performanceCache.stats.ahCalcHits++;
                    return performanceCache.asianHandicapResults.get(cacheKey);
                }
                
                // Calculate result
                let result;
                if (handicap.includes('/')) {
                    result = this._calculateQuarterHandicap(homeScore, awayScore, handicap, betSide, odds, stake);
                } else {
                    result = this._calculateSimpleHandicap(homeScore, awayScore, handicap, betSide, odds, stake);
                }
                
                // Cache the result
                performanceCache.asianHandicapResults.set(cacheKey, result);
                performanceCache.stats.ahCalcMisses++;
                
                return result;
            }
            
            static _calculateQuarterHandicap(homeScore, awayScore, handicap, betSide, odds, stake) {
                const parts = handicap.split('/');
                const h1 = parseFloat(parts[0]);
                const h2 = parseFloat(parts[1]);
                const halfStake = stake / 2;
                
                const result1 = this._calculateSimpleHandicapResult(homeScore, awayScore, h1, betSide);
                const result2 = this._calculateSimpleHandicapResult(homeScore, awayScore, h2, betSide);
                
                let totalPayout = 0;
                if (result1 === 1) totalPayout += halfStake * odds;
                else if (result1 === 0) totalPayout += halfStake;
                if (result2 === 1) totalPayout += halfStake * odds;
                else if (result2 === 0) totalPayout += halfStake;
                
                const totalProfit = totalPayout - stake;
                let outcome = totalProfit > 0 ? 'win' : totalProfit < 0 ? 'loss' : 'push';
                
                return {
                    outcome: outcome,
                    payout: Math.round(totalPayout * 100) / 100,
                    profit: Math.round(totalProfit * 100) / 100
                };
            }
            
            static _calculateSimpleHandicap(homeScore, awayScore, handicap, betSide, odds, stake) {
                const h = parseFloat(handicap);
                const result = this._calculateSimpleHandicapResult(homeScore, awayScore, h, betSide);
                
                let payout = 0;
                if (result === 1) payout = stake * odds;
                else if (result === 0) payout = stake;
                
                const profit = payout - stake;
                let outcome = profit > 0 ? 'win' : profit < 0 ? 'loss' : 'push';
                
                return {
                    outcome: outcome,
                    payout: Math.round(payout * 100) / 100,
                    profit: Math.round(profit * 100) / 100
                };
            }
            
            static _calculateSimpleHandicapResult(homeScore, awayScore, handicap, betSide) {
                const adjustedHomeScore = homeScore + handicap;
                if (adjustedHomeScore > awayScore) {
                    return betSide === 'home' ? 1 : -1;
                } else if (adjustedHomeScore < awayScore) {
                    return betSide === 'away' ? 1 : -1;
                } else {
                    return 0;
                }
            }
        }
        
        // Utility functions
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(value);
        }
        
        function formatPercent(value) {
            return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
        }
        
        function getProfitColorClass(value) {
            if (value > 0) return 'profit-positive';
            if (value < 0) return 'profit-negative';
            return 'profit-neutral';
        }
        
        function toStartCase(str) {
            return str
                // Insert space before uppercase letters (for camelCase)
                .replace(/([a-z])([A-Z])/g, '$1 $2')
                // Insert space before numbers
                .replace(/([a-zA-Z])(\d)/g, '$1 $2')
                // Insert space after numbers
                .replace(/(\d)([a-zA-Z])/g, '$1 $2')
                // Split by various delimiters and join with spaces
                .replace(/[_-]+/g, ' ')
                // Capitalize first letter of each word
                .replace(/\b\w/g, l => l.toUpperCase())
                // Clean up multiple spaces
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        function abbreviateTeamName(teamName) {
            // Smart team name abbreviations to avoid collisions
            const abbreviations = {
                'Manchester United': 'Man Utd',
                'Manchester City': 'Man City',
                'Tottenham Hotspur': 'Spurs',
                'Brighton & Hove Albion': 'Brighton',
                'Brighton': 'Brighton',
                'Newcastle United': 'Newcastle',
                'Sheffield United': 'Sheffield',
                'West Ham United': 'West Ham',
                'Wolverhampton Wanderers': 'Wolves',
                'Wolverhampton': 'Wolves',
                'Leicester City': 'Leicester',
                'Norwich City': 'Norwich',
                'Crystal Palace': 'C Palace',
                'Nottingham Forest': "Nott'm F",
                'Aston Villa': 'Villa',
                'Southampton': 'Saints',
                'Bournemouth': 'Bmth'
            };
            
            // Use custom abbreviation if available
            if (abbreviations[teamName]) {
                return abbreviations[teamName];
            }
            
            // Fallback: take first word and limit to 8 chars
            const firstWord = teamName.split(' ')[0];
            return firstWord.length > 8 ? firstWord.substring(0, 8) : firstWord;
        }
        
        function evaluateFactorExpression(match, expression) {
            // Create cache key
            const cacheKey = `${match.matchKey}|${expression}`;
            
            // Check cache first
            if (performanceCache.factorEvaluations.has(cacheKey)) {
                performanceCache.stats.factorEvalHits++;
                return performanceCache.factorEvaluations.get(cacheKey);
            }
            
            // Calculate result
            let result;
            try {
                const context = {
                    match: match.match || {},
                    fbref: match.fbref || {},
                    timeSeries: match.timeSeries || {},
                    preMatch: match.enhanced?.preMatch || {},
                    postMatch: match.enhanced?.postMatch || {},
                    Math: Math
                };
                
                result = new Function(...Object.keys(context), `return ${expression}`)(...Object.values(context));
            } catch (error) {
                console.warn(`Error evaluating expression: ${expression}`, error);
                result = false;
            }
            
            // Cache the result
            performanceCache.factorEvaluations.set(cacheKey, result);
            performanceCache.stats.factorEvalMisses++;
            
            return result;
        }
        
        // PERFORMANCE: Cached match filtering
        function getFilteredMatches(factors) {
            // Create cache key from factor combination
            const factorHash = factors.map(f => `${f.category}:${f.key}`).sort().join('|');
            
            // Check cache first
            if (performanceCache.filteredMatches.has(factorHash)) {
                performanceCache.stats.matchFilterHits++;
                return performanceCache.filteredMatches.get(factorHash);
            }
            
            // Filter matches
            const filteredMatches = allMatches.filter(match => {
                return factors.every(factor => {
                    return evaluateFactorExpression(match, factor.expression);
                });
            });
            
            // Cache the result
            performanceCache.filteredMatches.set(factorHash, filteredMatches);
            performanceCache.stats.matchFilterMisses++;
            
            return filteredMatches;
        }
        
        // PERFORMANCE: Generate hash for betting configuration
        function getBettingConfigHash(matches, sideSelection, sizeSelection) {
            // Create hash from match keys + side + size
            const matchKeys = matches.map(m => m.matchKey).sort().join(',');
            const sideKey = `${sideSelection.category}:${sideSelection.key}`;
            const sizeKey = `${sizeSelection.category}:${sizeSelection.key}`;
            
            // Simple hash function
            const str = `${matchKeys}|${sideKey}|${sizeKey}`;
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString();
        }
        
        // Load factor definitions from JSON file
        async function loadFactorDefinitions() {
            try {
                const response = await fetch('src/pattern-discovery/factor_definitions.json');
                if (!response.ok) {
                    throw new Error(`Failed to load factor definitions: ${response.statusText}`);
                }
                
                factorDefinitions = await response.json();
                
                console.log('✅ Factor definitions loaded:', Object.keys(factorDefinitions));
                return true;
                
            } catch (error) {
                console.error('❌ Error loading factor definitions:', error);
                
                // Fallback to minimal factors if loading fails
                factorDefinitions = {
                    side: {
                        home: { expression: "true", description: "Bet on home team", betSide: "home" },
                        away: { expression: "true", description: "Bet on away team", betSide: "away" },
                        higherOdds: { expression: "true", description: "Bet on team with higher odds", betSide: "match.asianHandicapOdds.homeOdds > match.asianHandicapOdds.awayOdds ? 'home' : 'away'" },
                        lowerOdds: { expression: "true", description: "Bet on team with lower odds", betSide: "match.asianHandicapOdds.homeOdds < match.asianHandicapOdds.awayOdds ? 'home' : 'away'" }
                    },
                    size: {
                        fix: { expression: "200", description: "Fixed $200 stake", stakingMethod: "fixed" },
                        dynamic: { expression: "match.asianHandicapOdds.homeOdds <= 1.88 || match.asianHandicapOdds.awayOdds <= 1.88 ? 200 : 200 + Math.floor((Math.max(match.asianHandicapOdds.homeOdds, match.asianHandicapOdds.awayOdds) - 1.88) * 100) * 150", description: "Variable staking", stakingMethod: "variable" }
                    }
                };
                
                return false;
            }
        }
        
        // Load data from JSON files
        async function loadData() {
            try {
                updateStatus('Loading factor definitions...');
                
                // Load factor definitions first
                await loadFactorDefinitions();
                
                updateStatus('Loading match data...');
                
                const dataFiles = [
                    'data/enhanced/year-2022-2023-enhanced.json',
                    'data/enhanced/year-2023-2024-enhanced.json',
                    'data/enhanced/year-2024-2025-enhanced.json'
                ];
                
                allMatches = [];
                for (let i = 0; i < dataFiles.length; i++) {
                    const file = dataFiles[i];
                    updateStatus(`Loading ${file.split('/').pop()} (${i + 1}/${dataFiles.length})`);
                    
                    const response = await fetch(file);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${file}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    if (data.matches) {
                        Object.keys(data.matches).forEach(matchKey => {
                            const match = data.matches[matchKey];
                            match.matchKey = matchKey;
                            match.season = data.metadata?.season || 'unknown';
                            allMatches.push(match);
                        });
                    }
                }
                
                updateStatus(`Ready | ${Object.keys(factorDefinitions).length} categories | ${allMatches.length} matches | 🚀 Performance cache active`);
                renderFactorSelection();
                updateResults();
                
            } catch (error) {
                updateStatus(`ERROR: ${error.message}`);
                
                document.getElementById('results').innerHTML = `
                    <div class="error">
                        <strong>Data Loading Error</strong><br>
                        ${error.message}<br>
                        Make sure you're serving this page from a web server and both the enhanced data files and factor_definitions.json are available.
                    </div>
                `;
            }
        }
        
        // Update status line
        function updateStatus(message) {
            document.getElementById('status-line').textContent = message;
        }
        
        // Update status with performance stats
        function updateStatusWithPerformance(baseMessage) {
            const hitRates = performanceCache.getHitRates();
            const totalCacheSize = performanceCache.factorEvaluations.size + 
                                 performanceCache.asianHandicapResults.size + 
                                 performanceCache.filteredMatches.size + 
                                 performanceCache.bettingResults.size;
            
            if (totalCacheSize > 0) {
                const statusMessage = `${baseMessage} | 💨 Cache: ${hitRates.factorEvaluation}% factor, ${hitRates.asianHandicap}% AH, ${hitRates.bettingResult}% results`;
                updateStatus(statusMessage);
            } else {
                updateStatus(baseMessage);
            }
        }
        
        // Render factor selection UI
        function renderFactorSelection() {
            if (Object.keys(factorDefinitions).length === 0) return;
            
            // Render mandatory factors
            const mandatoryContainer = document.getElementById('mandatory-factors');
            mandatoryContainer.innerHTML = '';
            
            // Handle both old structure (direct side/size) and new structure (nested in mandatory)
            const sideFactors = factorDefinitions.side || factorDefinitions.mandatory?.side || {};
            const sizeFactors = factorDefinitions.size || factorDefinitions.mandatory?.size || {};
            
            // Create mandatory grid
            const mandatoryGrid = document.createElement('div');
            mandatoryGrid.className = 'mandatory-grid';
            
            // Add SIDE factors (sorted by ROI)
            const sideFactorsWithRoi = [];
            Object.keys(sideFactors).forEach(factorKey => {
                const factor = sideFactors[factorKey];
                const isSelected = selectedSide?.key === factorKey;
                
                let roi = 0;
                let roiHtml = '';
                
                // Calculate ROI if this side is selected with current size
                if (!isSelected && selectedSize && allMatches.length > 0) {
                    try {
                        const tempSide = { category: 'side', key: factorKey, ...factor };
                        const tempMatches = getFilteredMatches(selectedFactors);
                        
                        if (tempMatches.length > 0) {
                            const tempResults = calculateBettingResults(tempMatches, tempSide, selectedSize);
                            roi = tempResults.summary.roi;
                            const matchCount = tempResults.summary.totalBets;
                            const roiClass = roi > 0 ? 'roi-positive' : roi < 0 ? 'roi-negative' : 'roi-neutral';
                            roiHtml = `<div class="factor-roi ${roiClass}">${matchCount} / ${roi.toFixed(2)}%</div>`;
                        }
                    } catch (error) {
                        // Silently ignore ROI calculation errors
                    }
                }
                
                sideFactorsWithRoi.push({ factorKey, factor, isSelected, roi, roiHtml });
            });
            
            // Sort by ROI (descending)
            sideFactorsWithRoi.sort((a, b) => b.roi - a.roi);
            
            // Render sorted SIDE factors
            sideFactorsWithRoi.forEach(({ factorKey, factor, isSelected, roiHtml }) => {                    
                const factorDiv = document.createElement('div');
                const negativeRoiClass = roiHtml.includes('roi-negative') ? ' negative-roi' : '';
                factorDiv.className = `mandatory-item ${isSelected ? 'selected' : ''}${negativeRoiClass}`;
                factorDiv.innerHTML = `
                    <div class="mandatory-item-name">SIDE: ${toStartCase(factorKey)}</div>
                    <div class="mandatory-item-desc">${factor.description}</div>
                    ${roiHtml}
                `;
                factorDiv.onclick = () => selectMandatoryFactor('side', factorKey, factor);
                mandatoryGrid.appendChild(factorDiv);
            });
            
            // Add SIZE factors (sorted by ROI)
            const sizeFactorsWithRoi = [];
            Object.keys(sizeFactors).forEach(factorKey => {
                const factor = sizeFactors[factorKey];
                const isSelected = selectedSize?.key === factorKey;
                
                let roi = 0;
                let roiHtml = '';
                
                // Calculate ROI if this size is selected with current side
                if (!isSelected && selectedSide && allMatches.length > 0) {
                    try {
                        const tempSize = { category: 'size', key: factorKey, ...factor };
                        const tempMatches = getFilteredMatches(selectedFactors);
                        
                        if (tempMatches.length > 0) {
                            const tempResults = calculateBettingResults(tempMatches, selectedSide, tempSize);
                            roi = tempResults.summary.roi;
                            const matchCount = tempResults.summary.totalBets;
                            const roiClass = roi > 0 ? 'roi-positive' : roi < 0 ? 'roi-negative' : 'roi-neutral';
                            roiHtml = `<div class="factor-roi ${roiClass}">${matchCount} / ${roi.toFixed(2)}%</div>`;
                        }
                    } catch (error) {
                        // Silently ignore ROI calculation errors
                    }
                }
                
                sizeFactorsWithRoi.push({ factorKey, factor, isSelected, roi, roiHtml });
            });
            
            // Sort by ROI (descending)
            sizeFactorsWithRoi.sort((a, b) => b.roi - a.roi);
            
            // Render sorted SIZE factors
            sizeFactorsWithRoi.forEach(({ factorKey, factor, isSelected, roiHtml }) => {                    
                const factorDiv = document.createElement('div');
                const negativeRoiClass = roiHtml.includes('roi-negative') ? ' negative-roi' : '';
                factorDiv.className = `mandatory-item ${isSelected ? 'selected' : ''}${negativeRoiClass}`;
                factorDiv.innerHTML = `
                    <div class="mandatory-item-name">SIZE: ${toStartCase(factorKey)}</div>
                    <div class="mandatory-item-desc">${factor.description}</div>
                    ${roiHtml}
                `;
                factorDiv.onclick = () => selectMandatoryFactor('size', factorKey, factor);
                mandatoryGrid.appendChild(factorDiv);
            });
            
            mandatoryContainer.appendChild(mandatoryGrid);
            
            // Render available factors
            const availableContainer = document.getElementById('available-factors');
            availableContainer.innerHTML = '';
            
            Object.keys(factorDefinitions).forEach(category => {
                // Skip mandatory categories and empty categories
                if (category === 'side' || category === 'size' || category === 'mandatory') return;
                if (!factorDefinitions[category] || Object.keys(factorDefinitions[category]).length === 0) return;
                
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'factor-section';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'factor-title';
                titleDiv.textContent = toStartCase(category);
                sectionDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'factor-grid';
                
                let hasVisibleFactors = false;
                
                // Collect all factors with their ROI data for sorting
                const factorsWithRoi = [];
                
                Object.keys(factorDefinitions[category]).forEach(factorKey => {
                    const factor = factorDefinitions[category][factorKey];
                    const isSelected = selectedFactors.some(f => f.category === category && f.key === factorKey);
                    
                    if (factor.expression && factor.description) {
                        hasVisibleFactors = true;
                        
                        let roi = 0;
                        let matchCount = 0;
                        let roiHtml = '';
                        
                        // Calculate ROI if we have mandatory factors and data loaded
                        if (!isSelected && selectedSide && selectedSize && allMatches.length > 0) {
                            try {
                                const tempFactors = [...selectedFactors, { category, key: factorKey, ...factor }];
                                const tempMatches = getFilteredMatches(tempFactors);
                                
                                if (tempMatches.length > 0) {
                                    const tempResults = calculateBettingResults(tempMatches, selectedSide, selectedSize);
                                    roi = tempResults.summary.roi;
                                    matchCount = tempResults.summary.totalBets;
                                    const roiClass = roi > 0 ? 'roi-positive' : roi < 0 ? 'roi-negative' : 'roi-neutral';
                                    roiHtml = `<div class="factor-roi ${roiClass}">${matchCount} / ${roi.toFixed(2)}%</div>`;
                                }
                            } catch (error) {
                                // Silently ignore ROI calculation errors
                            }
                        }
                        
                        factorsWithRoi.push({
                            factorKey,
                            factor,
                            isSelected,
                            roi,
                            matchCount,
                            roiHtml
                        });
                    }
                });
                
                // Sort factors by ROI (descending)
                factorsWithRoi.sort((a, b) => b.roi - a.roi);
                
                // Render sorted factors
                factorsWithRoi.forEach(({ factorKey, factor, isSelected, roiHtml }) => {
                    const factorDiv = document.createElement('div');
                    const negativeRoiClass = roiHtml.includes('roi-negative') ? ' negative-roi' : '';
                    factorDiv.className = `factor-item ${isSelected ? 'selected' : ''}${negativeRoiClass}`;
                    factorDiv.innerHTML = `
                        <div class="factor-name">${toStartCase(factorKey)}</div>
                        <div class="factor-desc">${factor.description}</div>
                        ${roiHtml}
                    `;
                    factorDiv.onclick = () => {
                        if (isSelected) {
                            deselectFactor(category, factorKey);
                        } else {
                            selectFactor(category, factorKey, factor);
                        }
                    };
                    gridDiv.appendChild(factorDiv);
                });
                
                if (hasVisibleFactors) {
                    sectionDiv.appendChild(gridDiv);
                    availableContainer.appendChild(sectionDiv);
                }
            });
        }
        
        // Select mandatory factor
        function selectMandatoryFactor(category, factorKey, factor) {
            if (category === 'side') {
                selectedSide = { category, key: factorKey, ...factor };
            } else if (category === 'size') {
                selectedSize = { category, key: factorKey, ...factor };
            }
            
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
        }
        
        // Select additional factor
        function selectFactor(category, factorKey, factor) {
            selectedFactors.push({ category, key: factorKey, ...factor });
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
        }
        
        // Remove selected factor
        function removeFactor(index) {
            selectedFactors.splice(index, 1);
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
        }
        
        // Deselect factor from sidebar
        function deselectFactor(category, factorKey) {
            const index = selectedFactors.findIndex(f => f.category === category && f.key === factorKey);
            if (index !== -1) {
                selectedFactors.splice(index, 1);
                renderFactorSelection();
                renderSelectedFactors();
                updateResults();
            }
        }
        
        // Render selected factors as tags
        function renderSelectedFactors() {
            const selectedContainer = document.getElementById('selected-factors-list');
            
            let tags = [];
            
            // Add mandatory selections
            if (selectedSide) {
                tags.push(`<div class="selected-tag mandatory" title="${selectedSide.description}">
                    SIDE: ${toStartCase(selectedSide.key)} <span class="remove-x" onclick="deselectMandatory('side')">×</span>
                </div>`);
            }
            
            if (selectedSize) {
                tags.push(`<div class="selected-tag mandatory" title="${selectedSize.description}">
                    SIZE: ${toStartCase(selectedSize.key)} <span class="remove-x" onclick="deselectMandatory('size')">×</span>
                </div>`);
            }
            
            // Add optional factors
            selectedFactors.forEach((factor, index) => {
                tags.push(`<div class="selected-tag" title="${factor.description}">
                    ${toStartCase(factor.category)}.${toStartCase(factor.key)} <span class="remove-x" onclick="removeFactor(${index})">×</span>
                </div>`);
            });
            
            if (tags.length === 0) {
                selectedContainer.innerHTML = '<div style="color: #666; font-size: 9px;">Select betting side and stake method to begin</div>';
            } else {
                selectedContainer.innerHTML = tags.join('');
            }
        }
        
        // Deselect mandatory factor
        function deselectMandatory(type) {
            if (type === 'side') {
                selectedSide = null;
            } else if (type === 'size') {
                selectedSize = null;
            }
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
        }
        
        // Update results based on selected factors
        function updateResults() {
            if (!allMatches.length) {
                document.getElementById('results').innerHTML = '<div class="loading">Loading strategy engine...</div>';
                return;
            }
            
            if (!selectedSide || !selectedSize) {
                document.getElementById('results').innerHTML = `
                    <div class="loading">
                        <strong>Configuration Required</strong><br><br>
                        Select betting side and staking method to begin analysis.<br><br>
                        Current: ${selectedSide ? 'SIDE: ' + selectedSide.key : 'SIDE: Not selected'}<br>
                        Current: ${selectedSize ? 'SIZE: ' + selectedSize.key : 'SIZE: Not selected'}
                    </div>
                `;
                return;
            }
            
            try {
                // Filter matches by selected factors (cached)
                const filteredMatches = getFilteredMatches(selectedFactors);
                
                // Calculate betting results (cached)
                currentResults = calculateBettingResults(filteredMatches, selectedSide, selectedSize);
                
                // Render results
                renderResults();
                
            } catch (error) {
                document.getElementById('results').innerHTML = `
                    <div class="error">
                        <strong>Analysis Error</strong><br>
                        ${error.message}<br>
                        Check factor selections and try again.
                    </div>
                `;
                console.error('Analysis error:', error);
            }
        }
        
        // Calculate betting results (with caching)
        function calculateBettingResults(matches, sideSelection, sizeSelection) {
            // Check cache first
            const configHash = getBettingConfigHash(matches, sideSelection, sizeSelection);
            if (performanceCache.bettingResults.has(configHash)) {
                performanceCache.stats.bettingResultHits++;
                return performanceCache.bettingResults.get(configHash);
            }
            
            const bettingRecords = [];
            let totalStake = 0;
            let totalPayout = 0;
            let wins = 0;
            let losses = 0;
            let pushes = 0;
            
            matches.forEach(match => {
                try {
                    const matchData = match.match || {};
                    const homeScore = matchData.homeScore || 0;
                    const awayScore = matchData.awayScore || 0;
                    const handicap = matchData.asianHandicapOdds?.homeHandicap;
                    
                    if (!handicap) return;
                    
                    // Determine betting side
                    let betSide = sideSelection.betSide;
                    if (typeof betSide === 'string' && betSide.includes('match.')) {
                        betSide = evaluateFactorExpression(match, betSide);
                    }
                    
                    // Determine stake size
                    let stake = 200;
                    if (sizeSelection.expression && sizeSelection.expression !== "200") {
                        stake = evaluateFactorExpression(match, sizeSelection.expression);
                    }
                    
                    // Get odds
                    const homeOdds = matchData.asianHandicapOdds?.homeOdds || 2.0;
                    const awayOdds = matchData.asianHandicapOdds?.awayOdds || 2.0;
                    const odds = betSide === 'home' ? homeOdds : awayOdds;
                    
                    // Skip invalid data
                    if (!odds || odds <= 1 || !stake || stake <= 0) return;
                    
                    // Calculate result
                    const result = AsianHandicapCalculator.calculate(homeScore, awayScore, handicap, betSide, odds, stake);
                    


                    // Create record
                    const record = {
                        matchKey: match.matchKey,
                        date: matchData.date,
                        homeTeam: matchData.homeTeam,
                        awayTeam: matchData.awayTeam,
                        score: `${homeScore}-${awayScore}`,
                        handicap: handicap,
                        betSide: betSide,
                        odds: odds,
                        stake: stake,
                        outcome: result.outcome,
                        payout: result.payout,
                        profit: result.profit,
                        week: match.fbref?.week || 0
                    };
                    
                    bettingRecords.push(record);
                    totalStake += stake;
                    totalPayout += result.payout;
                    
                    if (result.outcome === 'win') wins++;
                    else if (result.outcome === 'loss') losses++;
                    else if (result.outcome === 'push') pushes++;
                    
                } catch (error) {
                    console.warn('Error calculating betting result:', error);
                }
            });
            
            const totalProfit = totalPayout - totalStake;
            const roi = totalStake > 0 ? (totalProfit / totalStake) * 100 : 0;
            const winRate = (wins + losses + pushes) > 0 ? (wins / (wins + losses + pushes)) * 100 : 0;
            
            const result = {
                bettingRecords,
                summary: {
                    totalBets: bettingRecords.length,
                    filteredMatches: matches.length,
                    totalMatches: allMatches.length,
                    totalStake: Math.round(totalStake * 100) / 100,
                    totalPayout: Math.round(totalPayout * 100) / 100,
                    totalProfit: Math.round(totalProfit * 100) / 100,
                    roi: Math.round(roi * 100) / 100,
                    winRate: Math.round(winRate * 100) / 100,
                    wins,
                    losses,
                    pushes
                }
            };
            
            // Cache the result
            performanceCache.bettingResults.set(configHash, result);
            performanceCache.stats.bettingResultMisses++;
            
            return result;
        }
        
        // Render results
        function renderResults() {
            if (!currentResults) return;
            
            const { summary, bettingRecords } = currentResults;
            
            const resultsHTML = `
                <div class="summary">
                    <div class="summary-header">Strategy Performance</div>
                    <div class="summary-stats">
                        Filtered ${summary.filteredMatches} matches from ${summary.totalMatches} total (${((summary.filteredMatches/summary.totalMatches)*100).toFixed(1)}% match rate)<br>
                        Active factors: ${selectedFactors.map(f => toStartCase(f.key)).join(', ') || 'Base strategy only'}
                    </div>
                    <div class="summary-grid">
                        <div class="summary-metric">
                            <div class="summary-value">${summary.totalBets}</div>
                            <div class="summary-label">Bets</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value">${formatCurrency(summary.totalStake)}</div>
                            <div class="summary-label">Stake</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${getProfitColorClass(summary.totalProfit)}">${formatCurrency(summary.totalProfit)}</div>
                            <div class="summary-label">Profit</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${getProfitColorClass(summary.roi)}">${formatPercent(summary.roi)}</div>
                            <div class="summary-label">ROI</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value">${summary.winRate.toFixed(1)}%</div>
                            <div class="summary-label">Win Rate</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value">${summary.wins}W/${summary.losses}L/${summary.pushes}P</div>
                            <div class="summary-label">Record</div>
                        </div>
                    </div>
                </div>
                
                <div class="records-section">
                    <div class="records-header">Betting Records (${bettingRecords.length} matches)</div>
                    <table class="records-table">
                        <thead>
                            <tr>
                                <th style="width: 8%;">Date</th>
                                <th style="width: 28%;">Match</th>
                                <th style="width: 8%;">Score</th>
                                <th style="width: 10%;">Handicap</th>
                                <th style="width: 6%;">Side</th>
                                <th style="width: 8%;">Odds</th>
                                <th style="width: 8%;">Stake</th>
                                <th style="width: 8%;">Result</th>
                                <th style="width: 8%;">P&L</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${bettingRecords.map(record => `
                                <tr>
                                    <td>${new Date(record.date).toLocaleDateString('en-GB', {day:'2-digit', month:'2-digit', year:'2-digit'})}</td>
                                    <td>${record.homeTeam} v ${record.awayTeam}</td>
                                    <td>${record.score}</td>
                                    <td>${record.handicap}</td>
                                    <td>${record.betSide.toUpperCase()}</td>
                                    <td>${record.odds.toFixed(2)}</td>
                                    <td>${formatCurrency(record.stake)}</td>
                                    <td>${record.outcome.toUpperCase()}</td>
                                    <td class="${getProfitColorClass(record.profit)}">${formatCurrency(record.profit)}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('results').innerHTML = resultsHTML;
            
            // Update status with performance info
            const baseStatus = `Ready | ${Object.keys(factorDefinitions).length} categories | ${allMatches.length} matches`;
            updateStatusWithPerformance(baseStatus);
        }
        
        // Initialize on page load
        window.onload = function() {
            console.log('🚀 Asian Handicap Factor Analysis Tool with Performance Optimization');
            console.log('💡 Performance Features:');
            console.log('   • Factor evaluation caching');
            console.log('   • Asian Handicap calculation caching');
            console.log('   • Match filtering caching');
            console.log('   • Complete betting result caching');
            console.log('⌨️  Shortcuts: Ctrl+Shift+C = Clear cache');
            
            updateStatus('Initializing...');
            loadData().then(() => {
                // Debug: Log match data structure
                if (allMatches.length > 0) {
                    console.log('🔍 MATCH DATA STRUCTURE DEBUG:');
                    console.log('Sample match object:', allMatches[0]);
                    console.log('Match fields:', Object.keys(allMatches[0]));
                    if (allMatches[0].preMatch) {
                        console.log('preMatch fields:', Object.keys(allMatches[0].preMatch));
                        if (allMatches[0].preMatch.match) {
                            console.log('preMatch.match fields:', Object.keys(allMatches[0].preMatch.match));
                        }
                        if (allMatches[0].preMatch.fbref) {
                            console.log('preMatch.fbref fields:', Object.keys(allMatches[0].preMatch.fbref));
                        }
                    }
                }
            });
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Ctrl+Shift+C to clear cache
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    performanceCache.clearAll();
                    updateStatus('Cache cleared - next calculations will be slower but fresh');
                    setTimeout(() => {
                        const baseStatus = `Ready | ${Object.keys(factorDefinitions).length} categories | ${allMatches.length} matches`;
                        updateStatusWithPerformance(baseStatus);
                    }, 2000);
                }
            });
        };
    </script>
</body>
</html> 
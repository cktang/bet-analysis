<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asian Handicap Factor Drilling Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="/analysis/js/AsianHandicapCalculator.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', monospace, sans-serif; background: #1a1a1a; color: #e0e0e0; font-size: 11px; }
        
        .container { display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        
        .top-bar { background: #2d2d2d; padding: 8px 12px; padding-right: 320px; border-bottom: 1px solid #404040; flex-shrink: 0; position: relative; }
        .app-title { color: #00ff88; font-weight: bold; font-size: 14px; margin-bottom: 4px; }
        .status-line { color: #888; font-size: 10px; }
        
        .pinned-strategies { 
            position: fixed; 
            top: 0; 
            right: 0; 
            width: 300px; 
            height: 160px; 
            background: #1e1e1e; 
            border-left: 1px solid #404040; 
            border-bottom: 1px solid #404040; 
            padding: 8px; 
            z-index: 100;
            overflow-y: auto;
        }
        .pinned-strategies-title { 
            color: #00bfff; 
            font-size: 9px; 
            font-weight: bold; 
            text-transform: uppercase; 
            margin-bottom: 6px; 
            padding-bottom: 4px;
            border-bottom: 1px solid #333;
        }
        .pinned-strategy { 
            display: flex; 
            flex-direction: column; 
            background: #2a2a2a; 
            margin: 3px 0; 
            padding: 6px 8px; 
            border-radius: 2px; 
            font-size: 9px; 
        }
        .pinned-strategy-name { 
            color: #00bfff; 
            cursor: pointer; 
            font-weight: bold; 
            margin-bottom: 2px;
        }
        .pinned-strategy-name:hover { 
            color: #64b5f6; 
        }
        .pinned-strategy-info { 
            color: #888; 
            font-size: 8px; 
            margin-bottom: 4px; 
        }
        .pinned-strategy-controls { 
            display: flex; 
            gap: 4px; 
            justify-content: flex-end;
        }
        .pinned-strategy-btn {
            background: #555;
            color: white;
            border: none;
            padding: 2px 6px;
            font-size: 8px;
            border-radius: 2px;
            cursor: pointer;
        }
        .pinned-strategy-btn:hover {
            background: #666;
        }
        .pinned-strategy-btn.danger {
            background: #d32f2f;
        }
        .pinned-strategy-btn.danger:hover {
            background: #f44336;
        }
        
        .selected-panel { background: #252525; padding: 8px 12px; border-bottom: 1px solid #404040; min-height: 60px; max-height: 100px; flex-shrink: 0; overflow-y: auto; }
        .selected-title { color: #00bfff; font-size: 10px; font-weight: bold; margin-bottom: 4px; text-transform: uppercase; }
        .selected-factors-list { display: flex; flex-wrap: wrap; gap: 4px; }
        .selected-tag { background: #1565c0; color: white; padding: 2px 6px; border-radius: 2px; font-size: 9px; display: flex; align-items: center; gap: 4px; }
        .selected-tag.mandatory { background: #d32f2f; }
        .remove-x { cursor: pointer; font-weight: bold; }
        .remove-x:hover { color: #ff6b6b; }
        
        .main-content { display: flex; flex: 1; min-height: 0; }
        .sidebar { width: 280px; background: #1e1e1e; border-right: 1px solid #404040; overflow-y: auto; flex-shrink: 0; }
        .results-panel { flex: 1; background: #1a1a1a; overflow-y: auto; min-width: 0; }
        
        .mandatory-section { background: #2d1b1b; border-bottom: 1px solid #404040; padding: 8px; }
        .mandatory-title { color: #ff6b6b; font-size: 9px; font-weight: bold; text-transform: uppercase; margin-bottom: 4px; }
        .mandatory-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        .mandatory-item { background: #3d2d2d; padding: 4px 6px; border-radius: 2px; cursor: pointer; border: 1px solid transparent; position: relative; overflow: hidden; }
        .mandatory-item:hover { border-color: #ff6b6b; }
        .mandatory-item.selected { background: #d32f2f; color: white; }
        .mandatory-item-name { font-weight: bold; font-size: 9px; }
        .mandatory-item-desc { font-size: 8px; color: #aaa; margin-top: 1px; }
        
        .factor-section { padding: 6px; border-bottom: 1px solid #333; }
        .factor-title { color: #00bfff; font-size: 9px; font-weight: bold; text-transform: uppercase; margin-bottom: 4px; padding: 2px 4px; background: #1a1a1a; }
        .factor-grid { display: flex; flex-wrap: wrap; gap: 2px; }
        .factor-item { 
            background: #2a2a2a; 
            padding: 3px 5px; 
            border-radius: 2px; 
            cursor: pointer; 
            border: 1px solid transparent; 
            position: relative;
            overflow: hidden;
            display: inline-block;
            min-width: fit-content;
        }
        .factor-item:hover { border-color: #00bfff; background: #333; }
        .factor-item.selected { background: #1565c0; color: white; }
        .factor-item.negative-roi { }
        
        .mandatory-item.negative-roi { }
        
        /* ROI Background Bar System */
        .factor-item::before, .mandatory-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: var(--roi-width, 0%);
            background: var(--roi-color, transparent);
            opacity: 0.25;
            pointer-events: none;
            z-index: 1;
        }
        
        .factor-item > *, .mandatory-item > * {
            position: relative;
            z-index: 2;
        }
        .factor-name { font-weight: bold; font-size: 9px; }
        .factor-desc { font-size: 8px; color: #888; margin-top: 1px; line-height: 1.2; }
        .factor-roi { font-size: 8px; font-weight: bold; margin-top: 1px; }
        .roi-positive { color: #00ff88; }
        .roi-negative { color: #ff6b6b; }
        .roi-neutral { color: #888; opacity: 0.7; }
        
        .results-content { padding: 12px; height: 100%; overflow-y: auto; box-sizing: border-box; }
        .summary { background: #252525; border: 1px solid #404040; padding: 10px; margin-bottom: 12px; flex-shrink: 0; }
        .summary-header { color: #00ff88; font-size: 10px; font-weight: bold; margin-bottom: 6px; text-transform: uppercase; }
        .summary-stats { font-size: 9px; color: #aaa; margin-bottom: 8px; line-height: 1.3; }
        .summary-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
        .summary-metric { text-align: center; }
        .summary-value { font-size: 12px; font-weight: bold; margin-bottom: 2px; }
        .summary-label { font-size: 8px; color: #888; text-transform: uppercase; }
        
        .profit-positive { color: #00ff88; }
        .profit-negative { color: #ff6b6b; }
        .profit-neutral { color: #888; }
        
        .chart-section { 
            background: #252525; 
            border: 1px solid #404040; 
            padding: 10px; 
            margin-bottom: 12px; 
            flex-shrink: 0; 
        }
        .chart-header { 
            color: #00bfff; 
            font-size: 10px; 
            font-weight: bold; 
            margin-bottom: 8px; 
            text-transform: uppercase; 
        }
        .chart-container { 
            position: relative; 
            height: 200px; 
            background: #1a1a1a; 
            border-radius: 4px; 
        }
        
        .records-section { flex-shrink: 0; }
        .records-header { color: #00bfff; font-size: 10px; font-weight: bold; margin-bottom: 6px; text-transform: uppercase; }
        .records-table { width: 100%; border-collapse: collapse; font-size: 9px; table-layout: fixed; }
        .records-table th { background: #2d2d2d; color: #00bfff; padding: 4px 6px; text-align: left; font-weight: bold; font-size: 8px; text-transform: uppercase; border: 1px solid #404040; position: sticky; top: 0; z-index: 10; }
        .records-table td { padding: 3px 6px; border: 1px solid #333; background: #1e1e1e; word-wrap: break-word; }
        .records-table tr:nth-child(even) td { background: #252525; }
        .records-table tr:hover td { background: #2a2a2a; }
        
        /* Column widths for betting records table */
        .records-table th:nth-child(1) { width: 40px; } /* Date */
        .records-table th:nth-child(2) { width: 200px; } /* Match - made wider */
        .records-table th:nth-child(3) { width: 50px; } /* Score */
        .records-table th:nth-child(4) { width: 70px; } /* Handicap */
        .records-table th:nth-child(5) { width: 45px; } /* Side */
        .records-table th:nth-child(6) { width: 50px; } /* Odds */
        .records-table th:nth-child(7) { width: 60px; } /* Stake */
        .records-table th:nth-child(8) { width: 55px; } /* Result */
        .records-table th:nth-child(9) { width: 60px; } /* P&L */
        
        .records-table td:nth-child(1) { width: 65px; } /* Date */
        .records-table td:nth-child(2) { width: 200px; } /* Match - made wider */
        .records-table td:nth-child(3) { width: 50px; } /* Score */
        .records-table td:nth-child(4) { width: 70px; } /* Handicap */
        .records-table td:nth-child(5) { width: 45px; } /* Side */
        .records-table td:nth-child(6) { width: 50px; } /* Odds */
        .records-table td:nth-child(7) { width: 60px; } /* Stake */
        .records-table td:nth-child(8) { width: 55px; } /* Result */
        .records-table td:nth-child(9) { width: 60px; } /* P&L */
        
        /* Factor columns - limit width for better layout */
        .records-table th:nth-child(n+10) { width: 50px; max-width: 50px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } /* Factor columns */
        .records-table td:nth-child(n+10) { width: 50px; max-width: 50px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } /* Factor columns */
        
        .team-link { color: #00bfff; cursor: pointer; text-decoration: underline; }
        .team-link:hover { color: #64b5f6; }
        
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); }
        .modal-content { background-color: #1e1e1e; margin: 2% auto; padding: 20px; border: 1px solid #404040; width: 90%; max-width: 1200px; height: 90%; overflow-y: auto; border-radius: 4px; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #404040; padding-bottom: 10px; }
        .modal-title { color: #00ff88; font-size: 16px; font-weight: bold; }
        .modal-close { color: #aaa; font-size: 24px; font-weight: bold; cursor: pointer; }
        .modal-close:hover { color: #fff; }
        .team-stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 20px; }
        .team-stat { background: #252525; padding: 10px; border: 1px solid #404040; text-align: center; }
        .team-stat-value { font-size: 14px; font-weight: bold; margin-bottom: 5px; }
        .team-stat-label { font-size: 10px; color: #888; text-transform: uppercase; }
        .team-matches-table { width: 100%; border-collapse: collapse; font-size: 10px; }
        .team-matches-table th { background: #2d2d2d; color: #00bfff; padding: 6px; text-align: left; font-weight: bold; font-size: 9px; text-transform: uppercase; border: 1px solid #404040; }
        .team-matches-table td { padding: 4px 6px; border: 1px solid #333; background: #1e1e1e; }
        .team-matches-table tr:nth-child(even) td { background: #252525; }
        .team-matches-table tr:hover td { background: #2a2a2a; }
        
        .strategy-controls { display: flex; gap: 8px; align-items: center; margin-top: 8px; padding-top: 8px; border-top: 1px solid #404040; }
        .strategy-input { background: #2a2a2a; border: 1px solid #404040; color: #e0e0e0; padding: 4px 8px; font-size: 9px; border-radius: 2px; width: 120px; }
        .strategy-btn { background: #1565c0; color: white; border: none; padding: 4px 8px; font-size: 9px; border-radius: 2px; cursor: pointer; }
        .strategy-btn:hover { background: #1976d2; }
        .strategy-btn.danger { background: #d32f2f; }
        .strategy-btn.danger:hover { background: #f44336; }
        .strategy-btn:disabled { background: #555; cursor: not-allowed; opacity: 0.6; }
        
        .saved-strategies { max-height: 120px; overflow-y: auto; margin-top: 8px; }
        .saved-strategy { display: flex; justify-content: space-between; align-items: center; background: #2a2a2a; margin: 2px 0; padding: 4px 8px; border-radius: 2px; font-size: 9px; }
        .saved-strategy-name { color: #00bfff; cursor: pointer; flex: 1; }
        .saved-strategy-name:hover { color: #64b5f6; }
        .saved-strategy-info { color: #888; font-size: 8px; margin-right: 8px; }
        .saved-strategy-controls { display: flex; gap: 4px; }
        
        .loading { text-align: center; padding: 40px; color: #888; font-size: 10px; }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #404040; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="app-title">Asian Handicap Factor Analysis</div>
            <div class="status-line" id="status-line">Initializing...</div>
            
            <!-- Pinned Saved Strategies -->
            <div class="pinned-strategies">
                <div class="pinned-strategies-title">Saved Strategies</div>
                <div id="pinnedSavedStrategies"></div>
            </div>
        </div>
        
        <!-- Selected Factors Panel -->
        <div class="selected-panel">
            <div class="selected-title">Active Strategy Factors</div>
            <div class="selected-factors-list" id="selected-factors-list">
                <div style="color: #666; font-size: 9px;">Select betting side and stake method to begin</div>
            </div>
            
            <!-- Strategy Controls -->
            <div class="strategy-controls">
                <input type="text" id="strategyName" class="strategy-input" placeholder="Strategy name..." maxlength="30">
                <button class="strategy-btn" onclick="saveStrategy()" id="saveBtn" disabled>Save</button>
                <button class="strategy-btn" onclick="clearStrategy()">Clear All</button>
                <button class="strategy-btn" onclick="exportStrategy()" id="exportBtn" disabled>Export</button>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importStrategy(event)">
                <button class="strategy-btn" onclick="document.getElementById('importFile').click()">Import</button>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar -->
            <div class="sidebar">
                <!-- Mandatory Factors -->
                <div class="mandatory-section">
                    <div class="mandatory-title">Required Parameters</div>
                    <div id="mandatory-factors"></div>
                </div>
                
                <!-- Available Factors -->
                <div id="available-factors"></div>
            </div>
            
            <!-- Results Panel -->
            <div class="results-panel">
                <div class="results-content">
                    <div id="results">
                        <div class="loading">Loading strategy engine...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Team Analysis Modal -->
    <div id="teamModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="modalTeamName">Team Analysis</div>
                <span class="modal-close" onclick="closeTeamModal()">&times;</span>
            </div>
            <div class="team-stats" id="teamStats"></div>
            <div class="team-matches-section">
                <h3 style="color: #00bfff; margin-bottom: 10px;">All Matches</h3>
                <table class="team-matches-table" id="teamMatchesTable">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Opponent</th>
                            <th>Venue</th>
                            <th>Score</th>
                            <th>Result</th>
                            <th>AH</th>
                            <th>AH Result</th>
                            <th>Streak</th>
                        </tr>
                    </thead>
                    <tbody id="teamMatchesBody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let allMatches = [];
        let selectedSide = null;
        let selectedSize = null;
        let selectedFactors = [];
        let currentResults = null;
        
        // Factor definitions (loaded dynamically from factor_definitions.js)
        let factorDefinitions = {};
        
        // PERFORMANCE OPTIMIZATION: Caching system
        const performanceCache = {
            // Cache for factor expression evaluations: "matchKey|expression" -> boolean
            factorEvaluations: new Map(),
            
            // Cache for Asian Handicap calculations: "homeScore|awayScore|handicap|betSide|odds|stake" -> result
            asianHandicapResults: new Map(),
            
            // Cache for filtered match lists: "factorCombinationHash" -> matchArray
            filteredMatches: new Map(),
            
            // Cache for complete betting results: "matchListHash|sideKey|sizeKey" -> results
            bettingResults: new Map(),
            
            // Performance stats
            stats: {
                factorEvalHits: 0,
                factorEvalMisses: 0,
                ahCalcHits: 0,
                ahCalcMisses: 0,
                matchFilterHits: 0,
                matchFilterMisses: 0,
                bettingResultHits: 0,
                bettingResultMisses: 0
            },
            
            // Clear all caches
            clearAll() {
                this.factorEvaluations.clear();
                this.asianHandicapResults.clear();
                this.filteredMatches.clear();
                this.bettingResults.clear();
                console.log('🧹 Performance cache cleared');
            },
            
            // Get cache hit rates
            getHitRates() {
                const factorRate = this.stats.factorEvalHits / (this.stats.factorEvalHits + this.stats.factorEvalMisses) * 100;
                const ahRate = this.stats.ahCalcHits / (this.stats.ahCalcHits + this.stats.ahCalcMisses) * 100;
                const filterRate = this.stats.matchFilterHits / (this.stats.matchFilterHits + this.stats.matchFilterMisses) * 100;
                const resultRate = this.stats.bettingResultHits / (this.stats.bettingResultHits + this.stats.bettingResultMisses) * 100;
                
                return {
                    factorEvaluation: isNaN(factorRate) ? 0 : factorRate.toFixed(1),
                    asianHandicap: isNaN(ahRate) ? 0 : ahRate.toFixed(1),
                    matchFilter: isNaN(filterRate) ? 0 : filterRate.toFixed(1),
                    bettingResult: isNaN(resultRate) ? 0 : resultRate.toFixed(1)
                };
            }
        };
        
        // Asian Handicap Calculator - loaded from external file
        // (Will be loaded from /analysis/js/AsianHandicapCalculator.js)
        
        // Utility functions
        function formatCurrency(value) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(value);
        }
        
        function formatPercent(value) {
            return `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
        }
        
        function getProfitColorClass(value) {
            if (value > 0) return 'profit-positive';
            if (value < 0) return 'profit-negative';
            return 'profit-neutral';
        }
        
        function toStartCase(str) {
            return str
                // Insert space before uppercase letters (for camelCase)
                .replace(/([a-z])([A-Z])/g, '$1 $2')
                // Insert space before numbers
                .replace(/([a-zA-Z])(\d)/g, '$1 $2')
                // Insert space after numbers
                .replace(/(\d)([a-zA-Z])/g, '$1 $2')
                // Split by various delimiters and join with spaces
                .replace(/[_-]+/g, ' ')
                // Capitalize first letter of each word
                .replace(/\b\w/g, l => l.toUpperCase())
                // Clean up multiple spaces
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        function abbreviateTeamName(teamName) {
            // Smart team name abbreviations to avoid collisions
            const abbreviations = {
                'Manchester United': 'Man Utd',
                'Manchester City': 'Man City',
                'Tottenham Hotspur': 'Spurs',
                'Brighton & Hove Albion': 'Brighton',
                'Brighton': 'Brighton',
                'Newcastle United': 'Newcastle',
                'Sheffield United': 'Sheffield',
                'West Ham United': 'West Ham',
                'Wolverhampton Wanderers': 'Wolves',
                'Wolverhampton': 'Wolves',
                'Leicester City': 'Leicester',
                'Norwich City': 'Norwich',
                'Crystal Palace': 'C Palace',
                'Nottingham Forest': "Nott'm F",
                'Aston Villa': 'Villa',
                'Southampton': 'Saints',
                'Bournemouth': 'Bmth'
            };
            
            // Use custom abbreviation if available
            if (abbreviations[teamName]) {
                return abbreviations[teamName];
            }
            
            // Fallback: take first word and limit to 8 chars
            const firstWord = teamName.split(' ')[0];
            return firstWord.length > 8 ? firstWord.substring(0, 8) : firstWord;
        }
        
        function evaluateFactorExpression(match, expression) {
            // Create cache key
            const cacheKey = `${match.matchKey}|${expression}`;
            
            // Check cache first
            if (performanceCache.factorEvaluations.has(cacheKey)) {
                performanceCache.stats.factorEvalHits++;
                return performanceCache.factorEvaluations.get(cacheKey);
            }
            
            // Calculate result - factors work directly with raw match data
            let result;
            try {
                const { preMatch, timeSeries } = match;
                result = new Function('match', 'preMatch', 'timeSeries', 'Math', `return ${expression}`)(match, preMatch, timeSeries, Math);
                
            } catch (error) {
                console.warn(`1 Error evaluating expression: ${expression}`, error, match);
                result = false;
            }
            
            // Cache the result
            performanceCache.factorEvaluations.set(cacheKey, result);
            performanceCache.stats.factorEvalMisses++;
            
            return result;
        }
        
        // PERFORMANCE: Cached match filtering
        function getFilteredMatches(factors) {
            // Create cache key from factor combination
            const factorHash = factors.map(f => `${f.category}:${f.key}`).sort().join('|');
            
            // Check cache first
            if (performanceCache.filteredMatches.has(factorHash)) {
                performanceCache.stats.matchFilterHits++;
                return performanceCache.filteredMatches.get(factorHash);
            }
            
            // Filter matches
            const filteredMatches = allMatches.filter(match => {
                return factors.every(factor => {
                    return evaluateFactorExpression(match, factor.expression);
                });
            });
            
            // Cache the result
            performanceCache.filteredMatches.set(factorHash, filteredMatches);
            performanceCache.stats.matchFilterMisses++;
            
            return filteredMatches;
        }
        
        // PERFORMANCE: Generate hash for betting configuration
        function getBettingConfigHash(matches, sideSelection, sizeSelection) {
            // Create hash from match keys + side + size
            const matchKeys = matches.map(m => m.matchKey).sort().join(',');
            const sideKey = `${sideSelection.category}:${sideSelection.key}`;
            const sizeKey = `${sizeSelection.category}:${sizeSelection.key}`;
            
            // Simple hash function
            const str = `${matchKeys}|${sideKey}|${sizeKey}`;
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return hash.toString();
        }
        
        // Load factor definitions from JSON file
        async function loadFactorDefinitions() {
            try {
                // Add cache-busting timestamp to ensure fresh data
                const cacheBuster = new Date().getTime();
                const response = await fetch(`/analysis/drill-data/factor_definitions.json?v=${cacheBuster}`);
                if (!response.ok) {
                    throw new Error(`Failed to load factor definitions: ${response.statusText}`);
                }
                
                factorDefinitions = await response.json();
                
                console.log('✅ Factor definitions loaded:', Object.keys(factorDefinitions));
                return true;
                
            } catch (error) {
                console.error('❌ Error loading factor definitions:', error);
                
                // Fallback to minimal factors if loading fails
                factorDefinitions = {
                    side: {
                        home: { expression: "true", description: "Bet on home team", betSide: "home" },
                        away: { expression: "true", description: "Bet on away team", betSide: "away" },
                        higherOdds: { expression: "true", description: "Bet on team with higher odds", betSide: "preMatch.match.asianHandicapOdds.homeOdds > preMatch.match.asianHandicapOdds.awayOdds ? 'home' : 'away'" },
                        lowerOdds: { expression: "true", description: "Bet on team with lower odds", betSide: "preMatch.match.asianHandicapOdds.homeOdds < preMatch.match.asianHandicapOdds.awayOdds ? 'home' : 'away'" }
                    },
                    size: {
                        fix: { expression: "200", description: "Fixed $200 stake", stakingMethod: "fixed" },
                        dynamic: { expression: "preMatch.match.asianHandicapOdds.homeOdds <= 1.88 || preMatch.match.asianHandicapOdds.awayOdds <= 1.88 ? 200 : 200 + Math.floor((Math.max(preMatch.match.asianHandicapOdds.homeOdds, preMatch.match.asianHandicapOdds.awayOdds) - 1.88) * 100) * 150", description: "Variable staking", stakingMethod: "variable" }
                    }
                };
                
                return false;
            }
        }
        
        // Load data from JSON files
        async function loadData() {
            try {
                updateStatus('Loading factor definitions...');
                
                // Load factor definitions first
                await loadFactorDefinitions();
                
                updateStatus('Loading match data...');
                
                const dataFiles = [
                    '/analysis/data/enhanced/year-2022-2023-enhanced.json',
                    '/analysis/data/enhanced/year-2023-2024-enhanced.json',
                    '/analysis/data/enhanced/year-2024-2025-enhanced.json'
                ];
                
                allMatches = [];
                for (let i = 0; i < dataFiles.length; i++) {
                    const file = dataFiles[i];
                    updateStatus(`Loading ${file.split('/').pop()} (${i + 1}/${dataFiles.length})`);
                    
                    const response = await fetch(file);
                    if (!response.ok) {
                        throw new Error(`Failed to load ${file}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    // Extract season from filename (e.g., "year-2023-2024-enhanced.json" -> "2023-24")
                    const seasonMatch = file.match(/year-(\d{4})-(\d{4})-enhanced\.json/);
                    const season = seasonMatch ? `${seasonMatch[1]}-${seasonMatch[2].slice(-2)}` : 'unknown';
                    
                    if (data.matches) {
                        Object.keys(data.matches).forEach(matchKey => {
                            const match = data.matches[matchKey];
                            // Create unique matchKey including season to avoid collisions
                            const uniqueMatchKey = `${season}_${matchKey}`;
                            match.matchKey = uniqueMatchKey;
                            match.originalMatchKey = matchKey;
                            match.season = season;
                            allMatches.push(match);
                        });
                    }
                }
                
                updateStatus(`Ready | ${Object.keys(factorDefinitions).length} categories | ${allMatches.length} matches | 🚀 Performance cache active`);
                renderFactorSelection();
                updateResults();
                await renderSavedStrategies();
                updateStrategyControls();
                
            } catch (error) {
                updateStatus(`ERROR: ${error.message}`);
                
                document.getElementById('results').innerHTML = `
                    <div class="error">
                        <strong>Data Loading Error</strong><br>
                        ${error.message}<br>
                        Make sure you're serving this page from a web server and both the enhanced data files and factor_definitions.json are available.
                    </div>
                `;
            }
        }
        
        // Update status line
        function updateStatus(message) {
            document.getElementById('status-line').textContent = message;
        }
        
        // Create profit chart
        let profitChart = null;
        
        function createProfitChart(bettingRecords) {
            const canvas = document.getElementById('profitChart');
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (profitChart) {
                profitChart.destroy();
            }
            
            if (!bettingRecords || bettingRecords.length === 0) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('No betting data available', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Sort records by date
            const sortedRecords = [...bettingRecords].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Calculate cumulative profit with proper time data
            let cumulativeProfit = 0;
            const chartData = sortedRecords.map((record, index) => {
                cumulativeProfit += record.profit;
                return {
                    x: new Date(record.date),
                    y: cumulativeProfit
                };
            });
            
            // Create the chart
            profitChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Cumulative Profit',
                        data: chartData,
                        borderColor: cumulativeProfit >= 0 ? '#00ff88' : '#ff6b6b',
                        backgroundColor: cumulativeProfit >= 0 ? 'rgba(0, 255, 136, 0.1)' : 'rgba(255, 107, 107, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: '#2d2d2d',
                            titleColor: '#e0e0e0',
                            bodyColor: '#e0e0e0',
                            borderColor: '#404040',
                            borderWidth: 1,
                            callbacks: {
                                title: function(context) {
                                    const index = context[0].dataIndex;
                                    const record = sortedRecords[index];
                                    return `${record.homeTeam} v ${record.awayTeam}`;
                                },
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const record = sortedRecords[index];
                                    const profit = record.profit >= 0 ? `+${formatCurrency(record.profit)}` : formatCurrency(record.profit);
                                    return [
                                        `Date: ${new Date(record.date).toLocaleDateString()}`,
                                        `Bet: ${profit} (${record.outcome.toUpperCase()})`,
                                        `Total: ${formatCurrency(context.parsed.y)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM dd'
                                }
                            },
                            grid: {
                                color: '#404040',
                                borderColor: '#404040'
                            },
                            ticks: {
                                color: '#888',
                                font: {
                                    size: 10
                                },
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            grid: {
                                color: '#404040',
                                borderColor: '#404040'
                            },
                            ticks: {
                                color: '#888',
                                font: {
                                    size: 10
                                },
                                callback: function(value) {
                                    return formatCurrency(value);
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                }
            });
        }
        
        // Update status with performance stats
        function updateStatusWithPerformance(baseMessage) {
            const hitRates = performanceCache.getHitRates();
            const totalCacheSize = performanceCache.factorEvaluations.size + 
                                 performanceCache.asianHandicapResults.size + 
                                 performanceCache.filteredMatches.size + 
                                 performanceCache.bettingResults.size;
            
            if (totalCacheSize > 0) {
                const statusMessage = `${baseMessage} | 💨 Cache: ${hitRates.asianHandicap}% AH, ${hitRates.bettingResult}% results`;
                updateStatus(statusMessage);
            } else {
                updateStatus(baseMessage);
            }
        }
        
        // Calculate ROI background bar properties
        function calculateRoiBar(roi) {
            if (!roi || roi === 0) {
                return { width: '0%', color: 'transparent' };
            }
            
            // Scale ROI to a reasonable bar width (max 100% width for ±20% ROI)
            const maxRoi = 20; // ROI values beyond ±20% will be capped for display
            const scaledRoi = Math.max(-maxRoi, Math.min(maxRoi, roi));
            const width = Math.abs(scaledRoi / maxRoi) * 100;
            
            // Color based on positive/negative ROI
            const color = roi > 0 ? '#00ff88' : '#ff0000'; // Light green for positive, bright red for negative
            
            return {
                width: `${width}%`,
                color: color
            };
        }
        
        // Render factor selection UI
        function renderFactorSelection() {
            if (Object.keys(factorDefinitions).length === 0) return;
            
            // Render mandatory factors
            const mandatoryContainer = document.getElementById('mandatory-factors');
            mandatoryContainer.innerHTML = '';
            
            // Handle both old structure (direct side/size) and new structure (nested in mandatory)
            const sideFactors = factorDefinitions.side || factorDefinitions.mandatory?.side || {};
            const sizeFactors = factorDefinitions.size || factorDefinitions.mandatory?.size || {};
            
            // Create mandatory grid
            const mandatoryGrid = document.createElement('div');
            mandatoryGrid.className = 'mandatory-grid';
            
            // Add SIDE factors (sorted by ROI)
            const sideFactorsWithRoi = [];
            Object.keys(sideFactors).forEach(factorKey => {
                const factor = sideFactors[factorKey];
                const isSelected = selectedSide?.key === factorKey;
                
                let roi = 0;
                let roiHtml = '';
                
                // Calculate ROI if this side is selected with current size
                if (!isSelected && selectedSize && allMatches.length > 0) {
                    try {
                        const tempSide = { category: 'side', key: factorKey, ...factor };
                        const tempMatches = getFilteredMatches(selectedFactors);
                        
                        if (tempMatches.length > 0) {
                            const tempResults = calculateBettingResults(tempMatches, tempSide, selectedSize);
                            roi = tempResults.summary.roi;
                            const matchCount = tempResults.summary.totalBets;
                            const roiClass = roi > 0 ? 'roi-positive' : roi < 0 ? 'roi-negative' : 'roi-neutral';
                            roiHtml = `<div class="factor-roi ${roiClass}">${matchCount} / ${roi.toFixed(2)}%</div>`;
                        }
                    } catch (error) {
                        // Silently ignore ROI calculation errors
                    }
                }
                
                sideFactorsWithRoi.push({ factorKey, factor, isSelected, roi, roiHtml });
            });
            
            // Sort by ROI (descending)
            sideFactorsWithRoi.sort((a, b) => b.roi - a.roi);
            
            // Render sorted SIDE factors
            sideFactorsWithRoi.forEach(({ factorKey, factor, isSelected, roi, roiHtml }) => {                    
                const factorDiv = document.createElement('div');
                const negativeRoiClass = roiHtml.includes('roi-negative') ? ' negative-roi' : '';
                factorDiv.className = `mandatory-item ${isSelected ? 'selected' : ''}${negativeRoiClass}`;
                
                // Apply ROI background bar
                const roiBarData = calculateRoiBar(roi);
                factorDiv.style.setProperty('--roi-width', roiBarData.width);
                factorDiv.style.setProperty('--roi-color', roiBarData.color);
                
                factorDiv.innerHTML = `
                    <div class="mandatory-item-name">SIDE: ${toStartCase(factorKey)}</div>
                    <div class="mandatory-item-desc">${factor.description}</div>
                    ${roiHtml}
                `;
                factorDiv.onclick = () => selectMandatoryFactor('side', factorKey, factor);
                mandatoryGrid.appendChild(factorDiv);
            });
            
            // Add SIZE factors (sorted by ROI)
            const sizeFactorsWithRoi = [];
            Object.keys(sizeFactors).forEach(factorKey => {
                const factor = sizeFactors[factorKey];
                const isSelected = selectedSize?.key === factorKey;
                
                let roi = 0;
                let roiHtml = '';
                
                // Calculate ROI if this size is selected with current side
                if (!isSelected && selectedSide && allMatches.length > 0) {
                    try {
                        const tempSize = { category: 'size', key: factorKey, ...factor };
                        const tempMatches = getFilteredMatches(selectedFactors);
                        
                        if (tempMatches.length > 0) {
                            const tempResults = calculateBettingResults(tempMatches, selectedSide, tempSize);
                            roi = tempResults.summary.roi;
                            const matchCount = tempResults.summary.totalBets;
                            const roiClass = roi > 0 ? 'roi-positive' : roi < 0 ? 'roi-negative' : 'roi-neutral';
                            roiHtml = `<div class="factor-roi ${roiClass}">${matchCount} / ${roi.toFixed(2)}%</div>`;
                        }
                    } catch (error) {
                        // Silently ignore ROI calculation errors
                    }
                }
                
                sizeFactorsWithRoi.push({ factorKey, factor, isSelected, roi, roiHtml });
            });
            
            // Sort by ROI (descending)
            sizeFactorsWithRoi.sort((a, b) => b.roi - a.roi);
            
            // Render sorted SIZE factors
            sizeFactorsWithRoi.forEach(({ factorKey, factor, isSelected, roi, roiHtml }) => {                    
                const factorDiv = document.createElement('div');
                const negativeRoiClass = roiHtml.includes('roi-negative') ? ' negative-roi' : '';
                factorDiv.className = `mandatory-item ${isSelected ? 'selected' : ''}${negativeRoiClass}`;
                
                // Apply ROI background bar
                const roiBarData = calculateRoiBar(roi);
                factorDiv.style.setProperty('--roi-width', roiBarData.width);
                factorDiv.style.setProperty('--roi-color', roiBarData.color);
                
                factorDiv.innerHTML = `
                    <div class="mandatory-item-name">SIZE: ${toStartCase(factorKey)}</div>
                    <div class="mandatory-item-desc">${factor.description}</div>
                    ${roiHtml}
                `;
                factorDiv.onclick = () => selectMandatoryFactor('size', factorKey, factor);
                mandatoryGrid.appendChild(factorDiv);
            });
            
            mandatoryContainer.appendChild(mandatoryGrid);
            
            // Render available factors
            const availableContainer = document.getElementById('available-factors');
            availableContainer.innerHTML = '';
            
            Object.keys(factorDefinitions).forEach(category => {
                // Skip mandatory categories and empty categories
                if (category === 'side' || category === 'size' || category === 'mandatory') return;
                if (!factorDefinitions[category] || Object.keys(factorDefinitions[category]).length === 0) return;
                
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'factor-section';
                
                const titleDiv = document.createElement('div');
                titleDiv.className = 'factor-title';
                titleDiv.textContent = toStartCase(category);
                sectionDiv.appendChild(titleDiv);
                
                const gridDiv = document.createElement('div');
                gridDiv.className = 'factor-grid';
                
                let hasVisibleFactors = false;
                
                // Collect all factors with their ROI data for sorting
                const factorsWithRoi = [];
                
                Object.keys(factorDefinitions[category]).forEach(factorKey => {
                    const factor = factorDefinitions[category][factorKey];
                    const isSelected = selectedFactors.some(f => f.category === category && f.key === factorKey);
                    
                    if (factor.expression && factor.description) {
                        hasVisibleFactors = true;
                        
                        let roi = 0;
                        let matchCount = 0;
                        let roiHtml = '';
                        
                        // Calculate ROI if we have mandatory factors and data loaded
                        if (!isSelected && selectedSide && selectedSize && allMatches.length > 0) {
                            try {
                                const tempFactors = [...selectedFactors, { category, key: factorKey, ...factor }];
                                const tempMatches = getFilteredMatches(tempFactors);
                                
                                if (tempMatches.length > 0) {
                                    const tempResults = calculateBettingResults(tempMatches, selectedSide, selectedSize);
                                    roi = tempResults.summary.roi;
                                    matchCount = tempResults.summary.totalBets;
                                    const roiClass = roi > 0 ? 'roi-positive' : roi < 0 ? 'roi-negative' : 'roi-neutral';
                                    roiHtml = `<div class="factor-roi ${roiClass}">${matchCount} / ${roi.toFixed(2)}%</div>`;
                                }
                            } catch (error) {
                                // Silently ignore ROI calculation errors
                            }
                        }
                        
                        factorsWithRoi.push({
                            factorKey,
                            factor,
                            isSelected,
                            roi,
                            matchCount,
                            roiHtml
                        });
                    }
                });
                
                // Sort factors by ROI (descending)
                factorsWithRoi.sort((a, b) => b.roi - a.roi);
                
                // Render sorted factors
                factorsWithRoi.forEach(({ factorKey, factor, isSelected, roi, roiHtml }) => {
                    const factorDiv = document.createElement('div');
                    const negativeRoiClass = roiHtml.includes('roi-negative') ? ' negative-roi' : '';
                    factorDiv.className = `factor-item ${isSelected ? 'selected' : ''}${negativeRoiClass}`;
                    
                    // Apply ROI background bar
                    const roiBarData = calculateRoiBar(roi);
                    factorDiv.style.setProperty('--roi-width', roiBarData.width);
                    factorDiv.style.setProperty('--roi-color', roiBarData.color);
                    
                    factorDiv.innerHTML = `
                        <div class="factor-name">${toStartCase(factorKey)}</div>
                        <div class="factor-desc">${factor.description}</div>
                        ${roiHtml}
                    `;
                    factorDiv.onclick = () => {
                        if (isSelected) {
                            deselectFactor(category, factorKey);
                        } else {
                            selectFactor(category, factorKey, factor);
                        }
                    };
                    gridDiv.appendChild(factorDiv);
                });
                
                if (hasVisibleFactors) {
                    sectionDiv.appendChild(gridDiv);
                    availableContainer.appendChild(sectionDiv);
                }
            });
        }
        
        // Select mandatory factor
        function selectMandatoryFactor(category, factorKey, factor) {
            if (category === 'side') {
                selectedSide = { category, key: factorKey, ...factor };
            } else if (category === 'size') {
                selectedSize = { category, key: factorKey, ...factor };
            }
            
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
            updateStrategyControls();
        }
        
        // Select additional factor
        function selectFactor(category, factorKey, factor) {
            selectedFactors.push({ category, key: factorKey, ...factor });
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
            updateStrategyControls();
        }
        
        // Remove selected factor
        function removeFactor(index) {
            selectedFactors.splice(index, 1);
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
            updateStrategyControls();
        }
        
        // Deselect factor from sidebar
        function deselectFactor(category, factorKey) {
            const index = selectedFactors.findIndex(f => f.category === category && f.key === factorKey);
            if (index !== -1) {
                selectedFactors.splice(index, 1);
                renderFactorSelection();
                renderSelectedFactors();
                updateResults();
                updateStrategyControls();
            }
        }
        
        // Render selected factors as tags
        function renderSelectedFactors() {
            const selectedContainer = document.getElementById('selected-factors-list');
            
            let tags = [];
            
            // Add mandatory selections
            if (selectedSide) {
                tags.push(`<div class="selected-tag mandatory" title="${selectedSide.description}">
                    SIDE: ${toStartCase(selectedSide.key)} <span class="remove-x" onclick="deselectMandatory('side')">×</span>
                </div>`);
            }
            
            if (selectedSize) {
                tags.push(`<div class="selected-tag mandatory" title="${selectedSize.description}">
                    SIZE: ${toStartCase(selectedSize.key)} <span class="remove-x" onclick="deselectMandatory('size')">×</span>
                </div>`);
            }
            
            // Add optional factors
            selectedFactors.forEach((factor, index) => {
                tags.push(`<div class="selected-tag" title="${factor.description}">
                    ${toStartCase(factor.category)}.${toStartCase(factor.key)} <span class="remove-x" onclick="removeFactor(${index})">×</span>
                </div>`);
            });
            
            if (tags.length === 0) {
                selectedContainer.innerHTML = '<div style="color: #666; font-size: 9px;">Select betting side and stake method to begin</div>';
            } else {
                selectedContainer.innerHTML = tags.join('');
            }
        }
        
        // Deselect mandatory factor
        function deselectMandatory(type) {
            if (type === 'side') {
                selectedSide = null;
            } else if (type === 'size') {
                selectedSize = null;
            }
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
            updateStrategyControls();
        }
        
        // Update results based on selected factors
        function updateResults() {
            if (!allMatches.length) {
                document.getElementById('results').innerHTML = '<div class="loading">Loading strategy engine...</div>';
                return;
            }
            
            if (!selectedSide || !selectedSize) {
                document.getElementById('results').innerHTML = `
                    <div class="loading">
                        <strong>Configuration Required</strong><br><br>
                        Select betting side and staking method to begin analysis.<br><br>
                        Current: ${selectedSide ? 'SIDE: ' + selectedSide.key : 'SIDE: Not selected'}<br>
                        Current: ${selectedSize ? 'SIZE: ' + selectedSize.key : 'SIZE: Not selected'}
                    </div>
                `;
                return;
            }
            
            try {
                // Filter matches by selected factors (cached)
                const filteredMatches = getFilteredMatches(selectedFactors);
                
                // Calculate betting results (cached)
                currentResults = calculateBettingResults(filteredMatches, selectedSide, selectedSize);
                
                // Render results
                renderResults();
                
            } catch (error) {
                document.getElementById('results').innerHTML = `
                    <div class="error">
                        <strong>Analysis Error</strong><br>
                        ${error.message}<br>
                        Check factor selections and try again.
                    </div>
                `;
                console.error('Analysis error:', error);
            }
        }
        
        // Calculate betting results (with caching)
        function calculateBettingResults(matches, sideSelection, sizeSelection) {
            // Check cache first
            const configHash = getBettingConfigHash(matches, sideSelection, sizeSelection);
            if (performanceCache.bettingResults.has(configHash)) {
                performanceCache.stats.bettingResultHits++;
                return performanceCache.bettingResults.get(configHash);
            }
            
            const bettingRecords = [];
            let totalStake = 0;
            let totalPayout = 0;
            let wins = 0;
            let losses = 0;
            let pushes = 0;
            
            matches.forEach(match => {
                try {
                    const matchData = match.preMatch?.match || {};
                    const homeScore = matchData.homeScore || 0;
                    const awayScore = matchData.awayScore || 0;
                    const handicap = matchData.asianHandicapOdds?.homeHandicap;
                    
                    if (handicap == null) return;
                    
                    // Determine betting side
                    let betSide = sideSelection.betSide;
                    if (typeof betSide === 'string' && betSide.includes('match.')) {
                        betSide = evaluateFactorExpression(match, betSide);
                    }
                    
                    // Determine stake size
                    let stake = 200;
                    if (sizeSelection.expression && sizeSelection.expression !== "200") {
                        stake = evaluateFactorExpression(match, sizeSelection.expression);
                    }
                    
                    // Skip invalid data early
                    if (!stake || stake <= 0) return;
                    
                    let result;
                    let odds; // Declare odds outside the blocks
                    
                    // Handle HAD betting vs Asian Handicap betting
                    if (betSide === 'home_had' || betSide === 'away_had') {
                        // HAD (Head-to-Head) betting using actual bookmaker HAD odds
                        const homeWinOdds = matchData.homeWinOdds;
                        const awayWinOdds = matchData.awayWinOdds;
                        
                        // Use actual HAD odds from bookmaker data
                        odds = betSide === 'home_had' ? homeWinOdds : awayWinOdds;
                        
                        // Skip invalid odds or missing HAD data
                        if (!odds || odds <= 1) return;
                        
                        // Calculate HAD result
                        result = AsianHandicapCalculator.calculate(homeScore, awayScore, handicap, betSide, odds, stake);
                    } else {
                        // Asian Handicap betting (original logic)
                        const homeOdds = matchData.asianHandicapOdds?.homeOdds || 2.0;
                        const awayOdds = matchData.asianHandicapOdds?.awayOdds || 2.0;
                        odds = betSide === 'home' ? homeOdds : awayOdds;
                        
                        // Skip invalid odds
                        if (!odds || odds <= 1) return;
                        
                        // Calculate AH result
                        result = AsianHandicapCalculator.calculate(homeScore, awayScore, handicap, betSide, odds, stake);
                    }
                    
                    // Note: Factor display values are now calculated at render time, no need to pre-calculate

                    // Create record
                    const record = {
                        matchKey: match.matchKey,
                        date: matchData.date,
                        homeTeam: matchData.homeTeam,
                        awayTeam: matchData.awayTeam,
                        score: `${homeScore}-${awayScore}`,
                        handicap: handicap,
                        betSide: betSide,
                        odds: odds,
                        stake: stake,
                        outcome: result.outcome,
                        payout: result.payout,
                        profit: result.profit,
                        week: match.preMatch?.fbref?.week || 0,
                        season: match.season || 'unknown',
                        match
                    };
                    
                    bettingRecords.push(record);
                    totalStake += stake;
                    totalPayout += result.payout;
                    
                    if (result.outcome === 'win' || result.outcome === 'half-win') wins++;
                    else if (result.outcome === 'loss' || result.outcome === 'half-loss') losses++;
                    else if (result.outcome === 'push') pushes++;
                    
                } catch (error) {
                    console.warn('Error calculating betting result:', error);
                }
            });
            
            const totalProfit = totalPayout - totalStake;
            const roi = totalStake > 0 ? (totalProfit / totalStake) * 100 : 0;
            const winRate = (wins + losses + pushes) > 0 ? (wins / (wins + losses + pushes)) * 100 : 0;
            
            const result = {
                bettingRecords,
                summary: {
                    totalBets: bettingRecords.length,
                    filteredMatches: matches.length,
                    totalMatches: allMatches.length,
                    totalStake: Math.round(totalStake * 100) / 100,
                    totalPayout: Math.round(totalPayout * 100) / 100,
                    totalProfit: Math.round(totalProfit * 100) / 100,
                    roi: Math.round(roi * 100) / 100,
                    winRate: Math.round(winRate * 100) / 100,
                    wins,
                    losses,
                    pushes
                }
            };
            
            // Cache the result
            performanceCache.bettingResults.set(configHash, result);
            performanceCache.stats.bettingResultMisses++;
            
            return result;
        }
        
        // Calculate risk metrics
        function calculateRiskMetrics(bettingRecords) {
            if (!bettingRecords || bettingRecords.length === 0) {
                return {
                    maxDrawdown: 0,
                    maxDrawdownPercent: 0,
                    recoveryFactor: 0,
                    profitFactor: 0,
                    sharpeRatio: 0,
                    maxConsecutiveLosses: 0,
                    volatility: 0,
                    timeToRecovery: 0
                };
            }
            
            // Sort records by date
            const sortedRecords = [...bettingRecords].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // For fixed-stake strategies, estimate initial bankroll more conservatively
            const avgBetSize = bettingRecords.reduce((sum, r) => sum + r.stake, 0) / bettingRecords.length;
            const totalStaked = bettingRecords.reduce((sum, r) => sum + r.stake, 0);
            
            // Use either 50x average bet OR 20% of total staked (whichever is larger)
            // This assumes you never risk more than 2-3% per bet
            const conservativeCapital = avgBetSize * 50;
            const stakingBasedCapital = totalStaked * 0.2;
            const initialCapital = Math.max(conservativeCapital, stakingBasedCapital);
            
            // Calculate cumulative profits and drawdown
            let cumulativeProfit = 0;
            let peak = 0;
            let maxDrawdown = 0;
            let maxDrawdownPercent = 0;
            let drawdownStartIndex = -1;
            let timeToRecovery = 0;
            let currentConsecutiveLosses = 0;
            let maxConsecutiveLosses = 0;
            
            const profits = [];
            const dailyReturns = [];
            
            sortedRecords.forEach((record, index) => {
                cumulativeProfit += record.profit;
                profits.push(cumulativeProfit);
                
                // Track peak (never let peak go below 0 at start)
                peak = Math.max(peak, cumulativeProfit, 0);
                
                // Track drawdown (difference from peak to current)
                const currentDrawdown = peak - cumulativeProfit;
                
                // Only track positive drawdowns (actual losses from peak)
                if (currentDrawdown > 0 && currentDrawdown > maxDrawdown) {
                    maxDrawdown = currentDrawdown;
                    if (drawdownStartIndex === -1) {
                        drawdownStartIndex = index;
                    }
                } else if (currentDrawdown <= 0 && drawdownStartIndex !== -1) {
                    // We've recovered - calculate recovery time
                    timeToRecovery = Math.max(timeToRecovery, index - drawdownStartIndex);
                    drawdownStartIndex = -1;
                }
                
                // Calculate percentage drawdown (relative to initial capital)
                if (initialCapital > 0) {
                    maxDrawdownPercent = Math.max(maxDrawdownPercent, (currentDrawdown / initialCapital) * 100);
                }
                
                // Track consecutive losses
                if (record.profit < 0) {
                    currentConsecutiveLosses++;
                    maxConsecutiveLosses = Math.max(maxConsecutiveLosses, currentConsecutiveLosses);
                } else {
                    currentConsecutiveLosses = 0;
                }
                
                // Calculate return percentage relative to running bankroll, not individual bet stake
                // This gives portfolio-level volatility, not individual bet volatility
                const runningBankroll = Math.max(initialCapital + cumulativeProfit, record.stake); // Prevent division by tiny numbers
                if (runningBankroll > 0) {
                    dailyReturns.push((record.profit / runningBankroll) * 100);
                }
            });
            
            // If still in drawdown at end, calculate time to recovery as remaining period
            if (drawdownStartIndex !== -1) {
                timeToRecovery = Math.max(timeToRecovery, sortedRecords.length - drawdownStartIndex);
            }
            
            // Calculate profit factor
            const grossProfits = sortedRecords.filter(r => r.profit > 0).reduce((sum, r) => sum + r.profit, 0);
            const grossLosses = Math.abs(sortedRecords.filter(r => r.profit < 0).reduce((sum, r) => sum + r.profit, 0));
            const profitFactor = grossLosses > 0 ? grossProfits / grossLosses : grossProfits > 0 ? 999 : 0;
            
            // Calculate volatility (standard deviation of returns)
            const avgReturn = dailyReturns.reduce((sum, r) => sum + r, 0) / dailyReturns.length;
            const variance = dailyReturns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / dailyReturns.length;
            const volatility = Math.sqrt(variance);
            
            // Calculate Sharpe ratio (assuming 0% risk-free rate)
            const sharpeRatio = volatility > 0 ? avgReturn / volatility : 0;
            
            // Calculate recovery factor
            const totalProfit = cumulativeProfit;
            const recoveryFactor = maxDrawdown > 0 ? totalProfit / maxDrawdown : totalProfit > 0 ? 999 : 0;
            
            return {
                maxDrawdown: Math.round(maxDrawdown * 100) / 100,
                maxDrawdownPercent: Math.round(maxDrawdownPercent * 100) / 100,
                recoveryFactor: Math.round(recoveryFactor * 100) / 100,
                profitFactor: Math.round(profitFactor * 100) / 100,
                sharpeRatio: Math.round(sharpeRatio * 100) / 100,
                maxConsecutiveLosses,
                volatility: Math.round(volatility * 100) / 100,
                timeToRecovery
            };
        }
        
        // Get risk metric color class and tooltip
        function getRiskMetricDisplay(metric, value) {
            const metrics = {
                maxDrawdown: {
                    good: value < 10000,
                    fair: value < 25000,
                    tooltip: "Maximum loss from peak equity. Lower is better. <$10k=Good, <$25k=Fair, >$25k=Poor"
                },
                maxDrawdownPercent: {
                    good: value < 15,
                    fair: value < 30,
                    tooltip: "Maximum drawdown as % of starting capital. Lower is better. <15%=Good, <30%=Fair, >30%=Poor"
                },
                recoveryFactor: {
                    good: value > 3,
                    fair: value > 1.5,
                    tooltip: "Total profit ÷ Max drawdown. Higher is better. >3=Good, >1.5=Fair, <1.5=Poor"
                },
                profitFactor: {
                    good: value > 2,
                    fair: value > 1.3,
                    tooltip: "Gross profits ÷ Gross losses. Higher is better. >2=Good, >1.3=Fair, <1.3=Poor"
                },
                sharpeRatio: {
                    good: value > 1,
                    fair: value > 0.5,
                    tooltip: "Risk-adjusted return ratio. Higher is better. >1=Good, >0.5=Fair, <0.5=Poor"
                },
                maxConsecutiveLosses: {
                    good: value < 5,
                    fair: value < 10,
                    tooltip: "Longest streak of consecutive losing bets. Lower is better. <5=Good, <10=Fair, >10=Poor"
                },
                volatility: {
                    good: value < 5,
                    fair: value < 15,
                    tooltip: "Standard deviation of returns. Lower is better. <5%=Good, <15%=Fair, >15%=Poor"
                }
            };
            
            const config = metrics[metric];
            if (!config) return { class: 'profit-neutral', tooltip: 'No description available' };
            
            let colorClass = 'profit-negative'; // Poor (red)
            if (config.good) colorClass = 'profit-positive'; // Good (green)
            else if (config.fair) colorClass = 'profit-neutral'; // Fair (gray)
            
            return {
                class: colorClass,
                tooltip: config.tooltip
            };
        }

        // Render results
        function renderResults() {
            if (!currentResults) return;
            
            const { summary, bettingRecords } = currentResults;
            
            // Get factors with displayExpressions - these should match what we evaluated
            const factorsWithDisplay = selectedFactors.filter(f => f.displayExpression);
            
            // Calculate risk metrics
            const riskMetrics = calculateRiskMetrics(bettingRecords);
            
            const resultsHTML = `
                <div class="summary">
                    <div class="summary-header">Strategy Performance</div>
                    <div class="summary-stats">
                        Filtered ${summary.filteredMatches} matches from ${summary.totalMatches} total (${((summary.filteredMatches/summary.totalMatches)*100).toFixed(1)}% match rate)<br>
                        Active factors: ${selectedFactors.map(f => toStartCase(f.key)).join(', ') || 'Base strategy only'}
                    </div>
                    <div class="summary-grid">
                        <div class="summary-metric">
                            <div class="summary-value">${summary.totalBets}</div>
                            <div class="summary-label">Bets</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value">${formatCurrency(summary.totalStake)}</div>
                            <div class="summary-label">Stake</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${getProfitColorClass(summary.totalProfit)}">${formatCurrency(summary.totalProfit)}</div>
                            <div class="summary-label">Profit</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${getProfitColorClass(summary.roi)}">${formatPercent(summary.roi)}</div>
                            <div class="summary-label">ROI</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value">${summary.winRate.toFixed(1)}%</div>
                            <div class="summary-label">Win Rate</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value">${summary.wins}W/${summary.losses}L/${summary.pushes}P</div>
                            <div class="summary-label">Record</div>
                        </div>
                    </div>
                </div>
                
                <div class="summary">
                    <div class="summary-header">Risk Analysis</div>
                    <div class="summary-stats">
                        Risk-adjusted performance metrics to evaluate strategy safety and consistency<br>
                        🟢 Green = Good | ⚪ Gray = Fair | 🔴 Red = Poor (hover for thresholds)
                    </div>
                    <div class="summary-grid">
                        <div class="summary-metric">
                            <div class="summary-value ${getRiskMetricDisplay('maxDrawdown', riskMetrics.maxDrawdown).class}" 
                                 title="${getRiskMetricDisplay('maxDrawdown', riskMetrics.maxDrawdown).tooltip}">
                                ${formatCurrency(riskMetrics.maxDrawdown)}
                            </div>
                            <div class="summary-label">Max Drawdown</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${getRiskMetricDisplay('maxDrawdownPercent', riskMetrics.maxDrawdownPercent).class}"
                                 title="${getRiskMetricDisplay('maxDrawdownPercent', riskMetrics.maxDrawdownPercent).tooltip}">
                                ${riskMetrics.maxDrawdownPercent.toFixed(1)}%
                            </div>
                            <div class="summary-label">Max DD %</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${getRiskMetricDisplay('recoveryFactor', riskMetrics.recoveryFactor).class}"
                                 title="${getRiskMetricDisplay('recoveryFactor', riskMetrics.recoveryFactor).tooltip}">
                                ${riskMetrics.recoveryFactor === 999 ? '∞' : riskMetrics.recoveryFactor.toFixed(2)}
                            </div>
                            <div class="summary-label">Recovery Factor</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${getRiskMetricDisplay('profitFactor', riskMetrics.profitFactor).class}"
                                 title="${getRiskMetricDisplay('profitFactor', riskMetrics.profitFactor).tooltip}">
                                ${riskMetrics.profitFactor === 999 ? '∞' : riskMetrics.profitFactor.toFixed(2)}
                            </div>
                            <div class="summary-label">Profit Factor</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${getRiskMetricDisplay('maxConsecutiveLosses', riskMetrics.maxConsecutiveLosses).class}"
                                 title="${getRiskMetricDisplay('maxConsecutiveLosses', riskMetrics.maxConsecutiveLosses).tooltip}">
                                ${riskMetrics.maxConsecutiveLosses}
                            </div>
                            <div class="summary-label">Max Loss Streak</div>
                        </div>
                        <div class="summary-metric">
                            <div class="summary-value ${riskMetrics.timeToRecovery > 0 ? 'profit-neutral' : 'profit-positive'}" 
                                 title="Number of bets to recover from max drawdown. Lower is better.">
                                ${riskMetrics.timeToRecovery}
                            </div>
                            <div class="summary-label">Recovery Time</div>
                        </div>
                    </div>
                </div>
                
                <div class="chart-section">
                    <div class="chart-header">Cumulative Profit Over Time</div>
                    <div class="chart-container">
                        <canvas id="profitChart"></canvas>
                    </div>
                </div>
                
                <div class="records-section">
                    <div class="records-header">Betting Records (${bettingRecords.length} matches)</div>
                    <table class="records-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Match</th>
                                <th>Score</th>
                                <th>Handicap</th>
                                <th>Side</th>
                                <th>Odds</th>
                                <th>Stake</th>
                                <th>Result</th>
                                <th>P&L</th>
                                ${factorsWithDisplay.map(factor => `
                                    <th title="${factor.description || factor.key}">${toStartCase(factor.key)}</th>
                                `).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${bettingRecords.map(record => `
                                <tr>
                                    <td>${new Date(record.date).toLocaleDateString('en-GB', {day:'2-digit', month:'2-digit', year:'2-digit'})}</td>
                                    <td>
                                        <span class="team-link" onclick="openTeamModal('${record.homeTeam}')">${record.homeTeam}</span> v 
                                        <span class="team-link" onclick="openTeamModal('${record.awayTeam}')">${record.awayTeam}</span>
                                        <span style="font-size: 8px; color: #666; margin-left: 4px;">(${record.season || 'S?'})</span>
                                    </td>
                                    <td>${record.score}</td>
                                    <td>${record.handicap}</td>
                                    <td>${record.betSide.toUpperCase()}</td>
                                    <td>${record.odds.toFixed(2)}</td>
                                    <td>${formatCurrency(record.stake)}</td>
                                    <td>${record.outcome.toUpperCase()}</td>
                                    <td class="${getProfitColorClass(record.profit)}">${formatCurrency(record.profit)}</td>
                                    ${factorsWithDisplay.map(factor => {
                                        const displayExpression = factor.displayExpression;
                                        let displayValue = '-';
                                        try {
                                            // Handle both string and array formats for displayExpression
                                            const expressions = Array.isArray(displayExpression) ? displayExpression : [displayExpression];
                                            const value = expressions.map(exp => {
                                                try {
                                                    return new Function('Math', 'preMatch', 'timeSeries', `return ${exp}`)(
                                                        Math,
                                                        record.match.preMatch || {},
                                                        record.match.timeSeries || {},
                                                    );
                                                } catch (error) {
                                                    console.warn(`Error evaluating display expression: ${exp}`, error, record);
                                                    return 'Error';
                                                }
                                            }).join(', ');
                                            displayValue = value ?? '-';
                                        } catch (error) {
                                            console.warn(`2 Error evaluating display expression for ${factor.key}:${displayExpression}`, error);
                                            displayValue = 'Error';
                                        }
                                        return `<td>${displayValue}</td>`;
                                    }).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('results').innerHTML = resultsHTML;
            
            // Create the profit chart
            try {
                createProfitChart(bettingRecords);
            } catch (error) {
                console.error('Error creating profit chart:', error);
                // Clear the chart canvas and show error message
                const canvas = document.getElementById('profitChart');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = '12px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('Chart error - check console', canvas.width / 2, canvas.height / 2);
                }
            }
            
            // Update status with performance info
            const baseStatus = `Ready | ${Object.keys(factorDefinitions).length} categories | ${allMatches.length} matches`;
            updateStatusWithPerformance(baseStatus);
        }
        
        // Team Analysis Functions
        function openTeamModal(teamName) {
            analyzeTeam(teamName);
            document.getElementById('teamModal').style.display = 'block';
        }
        
        function closeTeamModal() {
            document.getElementById('teamModal').style.display = 'none';
        }
        
        function analyzeTeam(teamName) {
            console.log(`🔍 Analyzing team: ${teamName}`);
            
            // Get all matches for this team
            const teamMatches = allMatches.filter(match => {
                const matchData = match.preMatch?.match || {};
                return matchData.homeTeam === teamName || matchData.awayTeam === teamName;
            }).sort((a, b) => new Date(a.preMatch?.match?.date || 0) - new Date(b.preMatch?.match?.date || 0));
            
            // Calculate team statistics
            let wins = 0, losses = 0, draws = 0;
            let ahWins = 0, ahLosses = 0, ahPushes = 0;
            let homeRecord = { wins: 0, losses: 0, draws: 0 };
            let awayRecord = { wins: 0, losses: 0, draws: 0 };
            let currentStreak = { type: '', count: 0 };
            let ahCurrentStreak = { type: '', count: 0 };
            
            teamMatches.forEach((match, index) => {
                const matchData = match.preMatch?.match || {};
                const isHome = matchData.homeTeam === teamName;
                const homeScore = matchData.homeScore || 0;
                const awayScore = matchData.awayScore || 0;
                const handicap = matchData.asianHandicapOdds?.homeHandicap;
                
                // Overall result
                let result = 'draw';
                if (isHome) {
                    if (homeScore > awayScore) { result = 'win'; wins++; homeRecord.wins++; }
                    else if (homeScore < awayScore) { result = 'loss'; losses++; homeRecord.losses++; }
                    else { draws++; homeRecord.draws++; }
                } else {
                    if (awayScore > homeScore) { result = 'win'; wins++; awayRecord.wins++; }
                    else if (awayScore < homeScore) { result = 'loss'; losses++; awayRecord.losses++; }
                    else { draws++; awayRecord.draws++; }
                }
                
                // Update current streak
                if (index === 0) {
                    currentStreak = { type: result, count: result === 'draw' ? 0 : 1 };
                } else if (result === currentStreak.type && result !== 'draw') {
                    currentStreak.count++;
                } else if (result !== 'draw') {
                    currentStreak = { type: result, count: 1 };
                }
                
                // Asian Handicap result
                if (handicap != null) {
                    const betSide = isHome ? 'home' : 'away';
                    const odds = isHome ? matchData.asianHandicapOdds?.homeOdds || 2.0 : matchData.asianHandicapOdds?.awayOdds || 2.0;
                    const ahResult = AsianHandicapCalculator.calculate(homeScore, awayScore, handicap, betSide, odds, 100);
                    
                    if (ahResult.outcome === 'win' || ahResult.outcome === 'half-win') ahWins++;
                    else if (ahResult.outcome === 'loss' || ahResult.outcome === 'half-loss') ahLosses++;
                    else ahPushes++;
                    
                    // Update AH streak
                    if (index === 0) {
                        ahCurrentStreak = { type: ahResult.outcome, count: ahResult.outcome === 'push' ? 0 : 1 };
                    } else if (ahResult.outcome === ahCurrentStreak.type && ahResult.outcome !== 'push') {
                        ahCurrentStreak.count++;
                    } else if (ahResult.outcome !== 'push') {
                        ahCurrentStreak = { type: ahResult.outcome, count: 1 };
                    }
                }
            });
            
            // Update modal content
            document.getElementById('modalTeamName').textContent = `${teamName} - Complete Analysis`;
            
            // Team statistics
            const totalMatches = teamMatches.length;
            const winRate = totalMatches > 0 ? (wins / totalMatches * 100).toFixed(1) : '0.0';
            const ahWinRate = (ahWins + ahLosses + ahPushes) > 0 ? (ahWins / (ahWins + ahLosses + ahPushes) * 100).toFixed(1) : '0.0';
            
            const statsHTML = `
                <div class="team-stat">
                    <div class="team-stat-value">${totalMatches}</div>
                    <div class="team-stat-label">Total Matches</div>
                </div>
                <div class="team-stat">
                    <div class="team-stat-value">${wins}W-${losses}L-${draws}D</div>
                    <div class="team-stat-label">Overall Record</div>
                </div>
                <div class="team-stat">
                    <div class="team-stat-value">${winRate}%</div>
                    <div class="team-stat-label">Win Rate</div>
                </div>
                <div class="team-stat">
                    <div class="team-stat-value">${homeRecord.wins}W-${homeRecord.losses}L-${homeRecord.draws}D</div>
                    <div class="team-stat-label">Home Record</div>
                </div>
                <div class="team-stat">
                    <div class="team-stat-value">${awayRecord.wins}W-${awayRecord.losses}L-${awayRecord.draws}D</div>
                    <div class="team-stat-label">Away Record</div>
                </div>
                <div class="team-stat">
                    <div class="team-stat-value">${ahWins}W-${ahLosses}L-${ahPushes}P</div>
                    <div class="team-stat-label">AH Record</div>
                </div>
                <div class="team-stat">
                    <div class="team-stat-value">${ahWinRate}%</div>
                    <div class="team-stat-label">AH Win Rate</div>
                </div>
                <div class="team-stat">
                    <div class="team-stat-value ${currentStreak.type === 'win' ? 'profit-positive' : currentStreak.type === 'loss' ? 'profit-negative' : ''}">${currentStreak.count} ${currentStreak.type.toUpperCase()}</div>
                    <div class="team-stat-label">Current Streak</div>
                </div>
            `;
            
            document.getElementById('teamStats').innerHTML = statsHTML;
            
            // Matches table
            const matchesHTML = teamMatches.map((match, index) => {
                const matchData = match.preMatch?.match || {};
                const isHome = matchData.homeTeam === teamName;
                const opponent = isHome ? matchData.awayTeam : matchData.homeTeam;
                const venue = isHome ? 'HOME' : 'AWAY';
                const homeScore = matchData.homeScore || 0;
                const awayScore = matchData.awayScore || 0;
                const score = `${homeScore}-${awayScore}`;
                
                // Overall result
                let result = 'DRAW';
                let resultClass = 'profit-neutral';
                if (isHome) {
                    if (homeScore > awayScore) { result = 'WIN'; resultClass = 'profit-positive'; }
                    else if (homeScore < awayScore) { result = 'LOSS'; resultClass = 'profit-negative'; }
                } else {
                    if (awayScore > homeScore) { result = 'WIN'; resultClass = 'profit-positive'; }
                    else if (awayScore < homeScore) { result = 'LOSS'; resultClass = 'profit-negative'; }
                }
                
                // AH result
                const handicap = matchData.asianHandicapOdds?.homeHandicap || 'N/A';
                let ahResult = 'N/A';
                let ahResultClass = '';
                
                if (handicap !== 'N/A') {
                    const betSide = isHome ? 'home' : 'away';
                    const odds = isHome ? matchData.asianHandicapOdds?.homeOdds || 2.0 : matchData.asianHandicapOdds?.awayOdds || 2.0;
                    const calculation = AsianHandicapCalculator.calculate(homeScore, awayScore, handicap, betSide, odds, 100);
                    ahResult = calculation.outcome.toUpperCase();
                    ahResultClass = (calculation.outcome === 'win' || calculation.outcome === 'half-win') ? 'profit-positive' : (calculation.outcome === 'loss' || calculation.outcome === 'half-loss') ? 'profit-negative' : 'profit-neutral';
                }
                
                // Get streak info from timeSeries if available
                let streakInfo = '';
                if (match.timeSeries) {
                    const teamSeries = isHome ? match.timeSeries.home : match.timeSeries.away;
                    if (teamSeries?.streaks?.overall?.current) {
                        const streak = teamSeries.streaks.overall.current;
                        streakInfo = `${streak.count} ${streak.type.toUpperCase()}`;
                    }
                }
                
                return `
                    <tr>
                        <td>${new Date(matchData.date).toLocaleDateString('en-GB', {day:'2-digit', month:'2-digit', year:'2-digit'})}</td>
                        <td>${opponent}</td>
                        <td>${venue}</td>
                        <td>${score}</td>
                        <td class="${resultClass}">${result}</td>
                        <td>${handicap}</td>
                        <td class="${ahResultClass}">${ahResult}</td>
                        <td>${streakInfo}</td>
                    </tr>
                `;
            }).join('');
            
            document.getElementById('teamMatchesBody').innerHTML = matchesHTML;
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('teamModal');
            if (event.target === modal) {
                closeTeamModal();
            }
        }
        
        // Strategy Save/Load Functions
        async function saveStrategy() {
            const name = document.getElementById('strategyName').value.trim();
            if (!name) {
                alert('Please enter a strategy name');
                return;
            }
            
            if (!selectedSide || !selectedSize) {
                alert('Please select both betting side and stake size before saving');
                return;
            }
            
            const strategy = {
                name: name,
                timestamp: Date.now(),
                side: selectedSide,
                size: selectedSize,
                factors: selectedFactors,
                performance: currentResults ? {
                    roi: currentResults.summary.roi,
                    totalBets: currentResults.summary.totalBets,
                    winRate: currentResults.summary.winRate,
                    totalProfit: currentResults.summary.totalProfit
                } : null
            };
            
            // Get existing strategies
            let savedStrategies = await getSavedStrategies();
            
            // Check if name already exists
            if (savedStrategies.some(s => s.name === name)) {
                if (!confirm(`Strategy "${name}" already exists. Overwrite?`)) {
                    return;
                }
                savedStrategies = savedStrategies.filter(s => s.name !== name);
            }
            
            // Add new strategy
            savedStrategies.push(strategy);
            
            // Save to localStorage
            localStorage.setItem('ah_strategies', JSON.stringify(savedStrategies));
            
            // Clear input and refresh display
            document.getElementById('strategyName').value = '';
            renderSavedStrategies();
            updateStatus(`Strategy "${name}" saved successfully`);
            
            console.log('💾 Strategy saved:', strategy);
        }
        
        async function loadStrategy(name) {
            const savedStrategies = await getSavedStrategies();
            const strategy = savedStrategies.find(s => s.name === name);
            
            if (!strategy) {
                alert('Strategy not found');
                return;
            }
            
            // Load the strategy
            selectedSide = strategy.side;
            selectedSize = strategy.size;
            selectedFactors = strategy.factors || [];
            
            // Refresh the UI
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
            updateStrategyControls();
            
            updateStatus(`Strategy "${name}" loaded successfully`);
            console.log('📂 Strategy loaded:', strategy);
        }
        
        async function deleteStrategy(name) {
            if (!confirm(`Delete strategy "${name}"?`)) {
                return;
            }
            
            let savedStrategies = await getSavedStrategies();
            savedStrategies = savedStrategies.filter(s => s.name !== name);
            
            localStorage.setItem('ah_strategies', JSON.stringify(savedStrategies));
            renderSavedStrategies();
            updateStatus(`Strategy "${name}" deleted`);
        }
        
        function clearStrategy() {
            if (selectedSide || selectedSize || selectedFactors.length > 0) {
                if (!confirm('Clear all selected factors?')) {
                    return;
                }
            }
            
            selectedSide = null;
            selectedSize = null;
            selectedFactors = [];
            
            renderFactorSelection();
            renderSelectedFactors();
            updateResults();
            updateStrategyControls();
            
            updateStatus('Strategy cleared');
        }
        
        function exportStrategy() {
            if (!selectedSide || !selectedSize) {
                alert('Please select both betting side and stake size before exporting');
                return;
            }
            
            const strategy = {
                name: document.getElementById('strategyName').value.trim() || 'Unnamed Strategy',
                timestamp: Date.now(),
                side: selectedSide,
                size: selectedSize,
                factors: selectedFactors,
                performance: currentResults ? {
                    roi: currentResults.summary.roi,
                    totalBets: currentResults.summary.totalBets,
                    winRate: currentResults.summary.winRate,
                    totalProfit: currentResults.summary.totalProfit
                } : null,
                exportedFrom: 'Asian Handicap Factor Drilling Tool'
            };
            
            const blob = new Blob([JSON.stringify(strategy, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ah_strategy_${strategy.name.replace(/[^a-z0-9]/gi, '_')}_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            updateStatus(`Strategy exported: ${a.download}`);
        }
        
        function importStrategy(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const strategy = JSON.parse(e.target.result);
                    
                    // Validate strategy structure
                    if (!strategy.side || !strategy.size) {
                        throw new Error('Invalid strategy file format');
                    }
                    
                    // Load the strategy
                    selectedSide = strategy.side;
                    selectedSize = strategy.size;
                    selectedFactors = strategy.factors || [];
                    
                    // Update name input
                    document.getElementById('strategyName').value = strategy.name || '';
                    
                    // Refresh the UI
                    renderFactorSelection();
                    renderSelectedFactors();
                    updateResults();
                    updateStrategyControls();
                    
                    updateStatus(`Strategy "${strategy.name}" imported successfully`);
                    console.log('📥 Strategy imported:', strategy);
                    
                } catch (error) {
                    alert('Error importing strategy: ' + error.message);
                    console.error('Import error:', error);
                }
            };
            reader.readAsText(file);
            
            // Clear the file input
            event.target.value = '';
        }
        
        async function getSavedStrategies() {
            try {
                const saved = localStorage.getItem('ah_strategies');
                if (saved) {
                    return JSON.parse(saved);
                }
                
                // If localStorage is empty, try to load from strategy.json
                console.log('📂 No saved strategies in localStorage, loading from strategy.json...');
                try {
                    const response = await fetch('strategy.json');
                    if (response.ok) {
                        const strategies = await response.json();
                        console.log(`✅ Loaded ${strategies.length} strategies from strategy.json`);
                        
                        // Save to localStorage for future use
                        localStorage.setItem('ah_strategies', JSON.stringify(strategies));
                        
                        return strategies;
                    } else {
                        console.log('⚠️ strategy.json not found or not accessible');
                    }
                } catch (fetchError) {
                    console.log('⚠️ Error loading strategy.json:', fetchError.message);
                }
                
                return [];
            } catch (error) {
                console.error('Error loading saved strategies:', error);
                return [];
            }
        }
        
        async function renderSavedStrategies() {
            const savedStrategies = await getSavedStrategies();
            const container = document.getElementById('pinnedSavedStrategies');
            
            if (savedStrategies.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 9px; text-align: center; padding: 20px;">No saved strategies</div>';
                return;
            }
            
            // Sort by timestamp (newest first)
            savedStrategies.sort((a, b) => b.timestamp - a.timestamp);
            
            const strategiesHTML = savedStrategies.map(strategy => {
                const perf = strategy.performance;
                const perfText = perf ? 
                    `${perf.totalBets} bets, ${perf.roi.toFixed(1)}% ROI` : 
                    'No performance data';
                
                const timeAgo = getTimeAgo(strategy.timestamp);
                
                return `
                    <div class="pinned-strategy">
                        <div class="pinned-strategy-name" onclick="loadStrategy('${strategy.name}')" title="Click to load: ${strategy.name}">
                            ${strategy.name}
                        </div>
                        <div class="pinned-strategy-info" title="${perfText}">
                            ${timeAgo} • ${perfText}
                        </div>
                        <div class="pinned-strategy-controls">
                            <button class="pinned-strategy-btn danger" onclick="deleteStrategy('${strategy.name}')" title="Delete strategy">×</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            container.innerHTML = strategiesHTML;
        }
        
        function getTimeAgo(timestamp) {
            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (days > 0) return `${days}d ago`;
            if (hours > 0) return `${hours}h ago`;
            if (minutes > 0) return `${minutes}m ago`;
            return 'Just now';
        }
        
        function updateStrategyControls() {
            const hasValidStrategy = selectedSide && selectedSize;
            document.getElementById('saveBtn').disabled = !hasValidStrategy;
            document.getElementById('exportBtn').disabled = !hasValidStrategy;
        }
        
        // Initialize on page load
        window.onload = function() {
            console.log('🚀 Asian Handicap Factor Analysis Tool with Performance Optimization');
            console.log('💡 Performance Features:');
            console.log('   • Factor evaluation caching');
            console.log('   • Asian Handicap calculation caching');
            console.log('   • Match filtering caching');
            console.log('   • Complete betting result caching');
            console.log('🎯 Interactive Features:');
            console.log('   • Click team names in betting records for detailed analysis');
            console.log('   • Complete match history and streak analysis per team');
            console.log('💾 Strategy Management:');
            console.log('   • Save/load factor combinations with localStorage');
            console.log('   • Export/import strategies as JSON files');
            console.log('   • Performance tracking for saved strategies');

            console.log('⌨️  Shortcuts: Ctrl+Shift+C = Clear cache, ESC = Close modal');
            
            updateStatus('Initializing...');
            loadData().then(() => {
                // Debug: Log match data structure
                if (allMatches.length > 0) {
                    console.log('🔍 MATCH DATA STRUCTURE DEBUG:');
                    console.log('Sample match object:', allMatches[0]);
                    console.log('Match fields:', Object.keys(allMatches[0]));
                    if (allMatches[0].preMatch) {
                        console.log('preMatch fields:', Object.keys(allMatches[0].preMatch));
                        if (allMatches[0].preMatch.match) {
                            console.log('preMatch.match fields:', Object.keys(allMatches[0].preMatch.match));
                        }
                        if (allMatches[0].preMatch.fbref) {
                            console.log('preMatch.fbref fields:', Object.keys(allMatches[0].preMatch.fbref));
                        }
                    }
                }
            });
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Ctrl+Shift+C to clear cache
                if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                    performanceCache.clearAll();
                    updateStatus('Cache cleared - next calculations will be slower but fresh');
                    setTimeout(() => {
                        const baseStatus = `Ready | ${Object.keys(factorDefinitions).length} categories | ${allMatches.length} matches`;
                        updateStatusWithPerformance(baseStatus);
                    }, 2000);
                }
                
                // ESC to close modal
                if (e.key === 'Escape') {
                    closeTeamModal();
                }
            });
        };
    </script>
</body>
</html> 